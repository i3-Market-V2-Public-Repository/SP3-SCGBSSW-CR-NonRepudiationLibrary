var nonRepudiationProofs=function(e){"use strict";var t=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;throw new Error("unable to locate global object")}(),r=t.crypto;class a extends Error{constructor(e){super(e),this.code=a.code,this.name=this.constructor.name,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}}a.code="ERR_JOSE_GENERIC";class n extends a{constructor(){super(...arguments),this.code=n.code}}n.code="ERR_JOSE_ALG_NOT_ALLOWED";class i extends a{constructor(){super(...arguments),this.code=i.code}}i.code="ERR_JOSE_NOT_SUPPORTED";class o extends a{constructor(){super(...arguments),this.code=o.code,this.message="decryption operation failed"}}o.code="ERR_JWE_DECRYPTION_FAILED";class s extends a{constructor(){super(...arguments),this.code=s.code}}s.code="ERR_JWE_INVALID";class c extends a{constructor(){super(...arguments),this.code=c.code}}c.code="ERR_JWS_INVALID";class d extends a{constructor(){super(...arguments),this.code=d.code}}d.code="ERR_JWK_INVALID";class p extends a{constructor(){super(...arguments),this.code=p.code,this.message="signature verification failed"}}p.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";const h=r.getRandomValues.bind(r),y=new TextEncoder,u=new TextDecoder,l=2**32;function w(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let a=0;return e.forEach((e=>{r.set(e,a),a+=e.length})),r}function f(e,t){return w(y.encode(e),new Uint8Array([0]),t)}function m(e,t,r){if(t<0||t>=l)throw new RangeError(`value must be >= 0 and <= 4294967295. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function g(e){const t=Math.floor(e/l),r=e%l,a=new Uint8Array(8);return m(a,t,0),m(a,r,4),a}function A(e){const t=new Uint8Array(4);return m(t,e),t}function E(e){return w(A(e.length),e)}const S=e=>{let r=e;"string"==typeof r&&(r=y.encode(r));const a=[];for(let e=0;e<r.length;e+=32768)a.push(String.fromCharCode.apply(null,r.subarray(e,e+32768)));return t.btoa(a.join("")).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")},b=e=>{let r=e;r instanceof Uint8Array&&(r=u.decode(r)),r=r.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return new Uint8Array(t.atob(r).split("").map((e=>e.charCodeAt(0))))}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};async function v(e){return e instanceof Uint8Array?{kty:"oct",k:S(e)}:(async e=>{if(!e.extractable)throw new TypeError("non-extractable key cannot be extracted as a JWK");const{ext:t,key_ops:a,alg:n,use:i,...o}=await r.subtle.exportKey("jwk",e);return o})(e)}const H=new Map([["A128CBC-HS256",128],["A128GCM",96],["A128GCMKW",96],["A192CBC-HS384",128],["A192GCM",96],["A192GCMKW",96],["A256CBC-HS512",128],["A256GCM",96],["A256GCMKW",96]]),C=e=>t=>{const r=H.get(t);if(!r)throw new i(`Unsupported JWE Algorithm: ${t}`);return e(new Uint8Array(r>>3))},P=(e,t)=>{if(t.length<<3!==H.get(e))throw new s("Invalid Initialization Vector length")},K=(e,t)=>{let r;switch(e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":if(r=parseInt(e.substr(-3),10),!(t instanceof Uint8Array))throw new TypeError(`${e} content encryption requires Uint8Array as key input`);break;case"A128GCM":case"A192GCM":case"A256GCM":r=parseInt(e.substr(1,3),10);break;default:throw new i(`Content Encryption Algorithm ${e} is unsupported either by JOSE or your javascript runtime`)}if(t instanceof Uint8Array){if(t.length<<3!==r)throw new s("Invalid Content Encryption Key length")}else{if(void 0===t.algorithm)throw new TypeError("Invalid Content Encryption Key type");{const{length:e}=t.algorithm;if(e!==r)throw new s("Invalid Content Encryption Key length")}}};const _=async(e,t,a,n,i)=>(K(e,a),P(e,n),"CBC"===e.substr(4,3)?async function(e,t,a,n,i){const o=parseInt(e.substr(1,3),10),s=await r.subtle.importKey("raw",a.subarray(o>>3),"AES-CBC",!1,["encrypt"]),c=await r.subtle.importKey("raw",a.subarray(0,o>>3),{hash:{name:"SHA-"+(o<<1)},name:"HMAC"},!1,["sign"]),d=new Uint8Array(await r.subtle.encrypt({iv:n,name:"AES-CBC"},s,t)),p=w(i,n,d,g(i.length<<3));return{ciphertext:d,tag:new Uint8Array((await r.subtle.sign("HMAC",c,p)).slice(0,o>>3))}}(e,t,a,n,i):async function(e,t,a,n){const i=t instanceof Uint8Array?await r.subtle.importKey("raw",t,"AES-GCM",!1,["encrypt"]):t,o=new Uint8Array(await r.subtle.encrypt({additionalData:n,iv:a,name:"AES-GCM",tagLength:128},i,e)),s=o.slice(-16);return{ciphertext:o.slice(0,-16),tag:s}}(t,a,n,i)),k=async()=>{throw new i('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation, e.g. using the "pako" module.')},W=async()=>{throw new i('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime.')},U=new Map([["A128CBC-HS256",256],["A128GCM",128],["A192CBC-HS384",384],["A192GCM",192],["A256CBC-HS512",512],["A256GCM",256]]),J=e=>t=>{const r=U.get(t);if(!r)throw new i(`Unsupported JWE Algorithm: ${t}`);return e(new Uint8Array(r>>3))},R=[{hash:{name:"SHA-256"},name:"HMAC"},!0,["sign"]];function M(e,t){if(e.algorithm.length!==parseInt(t.substr(1,3),10))throw new TypeError(`invalid key size for alg: ${t}`)}const x=async(e,t,a)=>{let n;n=t instanceof Uint8Array?await r.subtle.importKey("raw",t,"AES-KW",!0,["wrapKey"]):t,M(n,e);const i=await r.subtle.importKey("raw",a,...R);return new Uint8Array(await r.subtle.wrapKey("raw",i,n,"AES-KW"))},T=async(e,t,a)=>{let n;n=t instanceof Uint8Array?await r.subtle.importKey("raw",t,"AES-KW",!0,["unwrapKey"]):t,M(n,e);const i=await r.subtle.unwrapKey("raw",a,n,"AES-KW",...R);return new Uint8Array(await r.subtle.exportKey("raw",i))},D=async(e,t)=>{const a=`SHA-${e.substr(-3)}`;return new Uint8Array(await r.subtle.digest(a,t))},O=async function(e,t,r,a){const n=Math.ceil((r>>3)/32);let i;for(let r=1;r<=n;r++){const n=new Uint8Array(4+t.length+a.length);n.set(A(r)),n.set(t,4),n.set(a,4+t.length),i=i?w(i,await e(n)):await e(n)}return i=i.slice(0,r>>3),i}.bind(void 0,D.bind(void 0,"sha256")),B=async(e,t,a,n,i=new Uint8Array(0),o=new Uint8Array(0))=>{const s=w(E(y.encode(a)),E(i),E(o),A(n));if(!t.usages.includes("deriveBits"))throw new TypeError('ECDH-ES private key "usages" must include "deriveBits"');const c=new Uint8Array(await r.subtle.deriveBits({name:"ECDH",public:e},t,Math.ceil(parseInt(t.algorithm.namedCurve.substr(-3),10)/8)<<3));return O(c,n,s)},I=["P-256","P-384","P-521"],G=e=>I.includes(e.algorithm.namedCurve);function $(e){if(!(e instanceof Uint8Array)||e.length<8)throw new s("PBES2 Salt Input must be 8 or more octets")}const j=async(e,t,a,n=Math.floor(2049*Math.random())+2048,i=h(new Uint8Array(16)))=>{$(i);const o=f(e,i),s=parseInt(e.substr(13,3),10),c={hash:{name:`SHA-${e.substr(8,3)}`},iterations:n,name:"PBKDF2",salt:o},d={length:s,name:"AES-KW"};let p,y;if(p=t instanceof Uint8Array?await r.subtle.importKey("raw",t,"PBKDF2",!1,["deriveBits"]):t,p.usages.includes("deriveBits"))y=new Uint8Array(await r.subtle.deriveBits(c,p,s));else{if(!p.usages.includes("deriveKey"))throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');y=await r.subtle.deriveKey(c,p,d,!1,["wrapKey"])}return{encryptedKey:await x(e.substr(-6),y,a),p2c:n,p2s:S(i)}},z=async(e,t,a,n,i)=>{$(i);const o=f(e,i),s=parseInt(e.substr(13,3),10),c={hash:{name:`SHA-${e.substr(8,3)}`},iterations:n,name:"PBKDF2",salt:o},d={length:s,name:"AES-KW"};let p,h;if(p=t instanceof Uint8Array?await r.subtle.importKey("raw",t,"PBKDF2",!1,["deriveBits"]):t,p.usages.includes("deriveBits"))h=new Uint8Array(await r.subtle.deriveBits(c,p,s));else{if(!p.usages.includes("deriveKey"))throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');h=await r.subtle.deriveKey(c,p,d,!1,["unwrapKey"])}return T(e.substr(-6),h,a)};function N(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new i(`alg ${e} is unsupported either by JOSE or your javascript runtime`)}}var F=(e,t)=>{if(e.startsWith("HS")){const r=parseInt(e.substr(-3),10),{length:a}=t.algorithm;if("number"!=typeof a||a<r)throw new TypeError(`${e} requires symmetric keys to be ${r} bits or larger`)}if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};async function L(e,t,a,n,i,s){const c=parseInt(e.substr(1,3),10),d=await r.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),p=await r.subtle.importKey("raw",t.subarray(0,c>>3),{hash:{name:"SHA-"+(c<<1)},name:"HMAC"},!1,["sign"]);let h;try{h=new Uint8Array(await r.subtle.decrypt({iv:n,name:"AES-CBC"},d,a))}catch(e){}const y=w(s,n,a,g(s.length<<3)),u=new Uint8Array((await r.subtle.sign("HMAC",p,y)).slice(0,c>>3));let l;try{l=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let a=0,n=-1;for(;++n<r;)a|=e[n]^t[n];return 0===a})(i,u)}catch(e){}if(!h||!l)throw new o;return h}const V=async(e,t,a,n,i,s)=>(K(e,t),P(e,n),"CBC"===e.substr(4,3)?L(e,t,a,n,i,s):async function(e,t,a,n,i){const s=e instanceof Uint8Array?await r.subtle.importKey("raw",e,"AES-GCM",!1,["decrypt"]):e;try{return new Uint8Array(await r.subtle.decrypt({additionalData:i,iv:a,name:"AES-GCM",tagLength:128},s,w(t,n)))}catch(e){throw new o}}(t,a,n,i,s)),q=C(h),Y=J(h);async function X(e,t,a,n,o={}){let s,c,d;switch(e){case"dir":d=a;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!G(a))throw new i("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const{apu:p,apv:h}=o;let{epk:y}=o;y||(y=await(async e=>(await r.subtle.generateKey({name:"ECDH",namedCurve:e.algorithm.namedCurve},!0,["deriveBits"])).privateKey)(a));const u=await async function(e){const{crv:t,kty:a,x:n,y:i}=await r.subtle.exportKey("jwk",e);return{crv:t,kty:a,x:n,y:i}}(y),l=await B(a,y,"ECDH-ES"===e?t:e,parseInt(e.substr(-5,3),10)||U.get(t),p,h);if(c={epk:u},p&&(c.apu=S(p)),h&&(c.apv=S(h)),"ECDH-ES"===e){d=l;break}d=n||Y(t);const w=e.substr(-6);s=await x(w,l,d);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":d=n||Y(t),s=await(async(e,t,a)=>{if(F(e,t),t.usages.includes("encrypt"))return new Uint8Array(await r.subtle.encrypt(N(e),t,a));if(t.usages.includes("wrapKey")){const n=await r.subtle.importKey("raw",a,...R);return new Uint8Array(await r.subtle.wrapKey("raw",n,t,N(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,a,d);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{d=n||Y(t);const{p2c:r,p2s:i}=o;({encryptedKey:s,...c}=await j(e,a,d,r,i));break}case"A128KW":case"A192KW":case"A256KW":d=n||Y(t),s=await x(e,a,d);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{d=n||Y(t);const{iv:r}=o;({encryptedKey:s,...c}=await(async(e,t,r,a)=>{const n=e.substr(0,7);a||(a=q(n));const{ciphertext:i,tag:o}=await _(n,r,t,a,new Uint8Array(0));return{encryptedKey:i,iv:S(a),tag:S(o)}})(e,a,d,r));break}default:throw new i('unsupported or invalid "alg" (JWE Algorithm) header value')}return{cek:d,encryptedKey:s,parameters:c}}const Q=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function Z(e,t,r,a,n){if(void 0!==n.crit&&void 0===a.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!a||void 0===a.crit)return new Set;if(!Array.isArray(a.crit)||0===a.crit.length||a.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;o=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of a.crit){if(!o.has(t))throw new i(`Extension Header Parameter "${t}" is not recognized`);if(void 0===n[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(o.get(t)&&void 0===a[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(a.crit)}const ee=C(h),te=Z.bind(void 0,s,new Map);class re{constructor(e){this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,t){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new s("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!Q(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new s("JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(te(null==t?void 0:t.crit,this._protectedHeader,r),void 0!==r.zip){if(!this._protectedHeader||!this._protectedHeader.zip)throw new s('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==r.zip)throw new i('unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:a,enc:n}=r;if("string"!=typeof a||!a)throw new s('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof n||!n)throw new s('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let o,c,d,p,h,l,f;if("dir"===a){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if("ECDH-ES"===a&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");{let t;({cek:c,encryptedKey:o,parameters:t}=await X(a,n,e,this._cek,this._keyManagementParameters)),t&&(this._protectedHeader?this._protectedHeader={...this._protectedHeader,...t}:this.setProtectedHeader(t))}if(this._iv||(this._iv=ee(n)),p=this._protectedHeader?y.encode(S(JSON.stringify(this._protectedHeader))):y.encode(""),this._aad?(h=S(this._aad),d=w(p,y.encode("."),y.encode(h))):d=p,"DEF"===r.zip){const e=await((null==t?void 0:t.deflateRaw)||W)(this._plaintext);({ciphertext:l,tag:f}=await _(n,e,c,this._iv,d))}else({ciphertext:l,tag:f}=await _(n,this._plaintext,c,this._iv,d));const m={ciphertext:S(l),iv:S(this._iv),tag:S(f)};return o&&(m.encrypted_key=S(o)),h&&(m.aad=h),this._protectedHeader&&(m.protected=u.decode(p)),this._sharedUnprotectedHeader&&(m.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(m.header=this._unprotectedHeader),m}}class ae{constructor(e){this._flattened=new re(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}function ne(e){return!!e&&e.constructor===Object}const ie=(e,t)=>{if("string"!=typeof e||!e)throw new d(`${t} missing or invalid`)};const oe=async e=>{var t,a;const{algorithm:n,keyUsages:o}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:{name:`SHA-${e.alg.substr(-3)}`}},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new i(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new i('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:{name:`SHA-${e.alg.substr(-3)}`}},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:{name:`SHA-${e.alg.substr(-3)}`}},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:{name:`SHA-${parseInt(e.alg.substr(-3),10)||1}`}},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new i('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":case"ES384":case"ES512":t={name:"ECDSA",namedCurve:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new i('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;default:throw new i('unsupported or invalid JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e);let s="jwk",c={...e};return delete c.alg,"PBKDF2"===n.name&&(s="raw",c=b(e.k)),r.subtle.importKey(s,c,n,null!==(t=e.ext)&&void 0!==t&&t,null!==(a=e.key_ops)&&void 0!==a?a:o)};async function se(e,t,r){if(!ne(e))throw new TypeError("JWK must be an object");if(t||(t=e.alg),"string"!=typeof t||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?oe({...e,alg:t,ext:!1}):b(e.k);case"RSA":if(void 0!==e.oth)throw new i('RSA JWK "oth" (Other Primes Info) Parameter value is unsupported');case"EC":case"OKP":return oe({...e,alg:t});default:throw new i('unsupported "kty" (Key Type) Parameter value')}}function ce(e){switch(e){case"HS256":return{hash:{name:"SHA-256"},name:"HMAC"};case"HS384":return{hash:{name:"SHA-384"},name:"HMAC"};case"HS512":return{hash:{name:"SHA-512"},name:"HMAC"};case"PS256":return{hash:{name:"SHA-256"},name:"RSA-PSS",saltLength:32};case"PS384":return{hash:{name:"SHA-384"},name:"RSA-PSS",saltLength:48};case"PS512":return{hash:{name:"SHA-512"},name:"RSA-PSS",saltLength:64};case"RS256":return{hash:{name:"SHA-256"},name:"RSASSA-PKCS1-v1_5"};case"RS384":return{hash:{name:"SHA-384"},name:"RSASSA-PKCS1-v1_5"};case"RS512":return{hash:{name:"SHA-512"},name:"RSASSA-PKCS1-v1_5"};case"ES256":return{hash:{name:"SHA-256"},name:"ECDSA",namedCurve:"P-256"};case"ES384":return{hash:{name:"SHA-384"},name:"ECDSA",namedCurve:"P-384"};case"ES512":return{hash:{name:"SHA-512"},name:"ECDSA",namedCurve:"P-521"};default:throw new i(`alg ${e} is unsupported either by JOSE or your javascript runtime`)}}const de=(e,t)=>{if(e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||e.match(/^A\d{3}(?:GCM)KW$/)){if(t instanceof Uint8Array||"secret"===t.type)return;throw new TypeError('CryptoKey or KeyObject instances for symmetric algorithms must be of type "secret"')}if(t instanceof Uint8Array)throw new TypeError("CryptoKey or KeyObject instances must be used for asymmetric algorithms");if("secret"===t.type)throw new TypeError('CryptoKey or KeyObject instances for asymmetric algorithms must not be of type "secret"')},pe=Z.bind(void 0,c,new Map([["b64",!0]]));class he{constructor(e){this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){if(!this._protectedHeader&&!this._unprotectedHeader)throw new c("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!Q(this._protectedHeader,this._unprotectedHeader))throw new c("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader};let n=!0;if(pe(null==t?void 0:t.crit,this._protectedHeader,a).has("b64")&&(n=this._protectedHeader.b64,"boolean"!=typeof n))throw new c('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=a;if("string"!=typeof i||!i)throw new c('JWS "alg" (Algorithm) Header Parameter missing or invalid');de(i,e);let o,s=this._payload;n&&(s=y.encode(S(s))),o=this._protectedHeader?y.encode(S(JSON.stringify(this._protectedHeader))):y.encode("");const d=w(o,y.encode("."),s),p=await(async(e,t,a)=>{let n;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError("symmetric keys are only applicable for HMAC-based algorithms");n=await r.subtle.importKey("raw",t,{hash:{name:`SHA-${e.substr(-3)}`},name:"HMAC"},!1,["sign"])}else n=t;F(e,n);const i=await r.subtle.sign(ce(e),n,a);return new Uint8Array(i)})(i,e,d),h={signature:S(p)};return n&&(h.payload=u.decode(s)),this._unprotectedHeader&&(h.header=this._unprotectedHeader),this._protectedHeader&&(h.protected=u.decode(o)),h}}class ye{constructor(e){this._flattened=new he(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}const ue=async function(e,t="SHA-256"){const r=["SHA-1","SHA-256","SHA-384","SHA-512"];if(!r.includes(t))throw new RangeError(`Valid hash algorith values are any of ${JSON.stringify(r)}`);const a=new TextEncoder,n="string"==typeof e?a.encode(e).buffer:e;let i="";{const e=await crypto.subtle.digest(t,n),r="0123456789abcdef";new Uint8Array(e).forEach((e=>{i+=r[e>>4]+r[15&e]}))}return i};function le(e){if(!e)throw new s("JWE Encrypted Key missing")}function we(e,t,r){if(void 0===e[t])throw new s(`JOSE Header ${r} (${t}) missing`)}async function fe(e,t,a,n){switch(e){case"dir":if(void 0!==a)throw new s("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==a)throw new s("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(we(n,"epk","Ephemeral Public Key"),!G(t))throw new i("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const s=await(o=n.epk,r.subtle.importKey("jwk",o,{name:"ECDH",namedCurve:o.crv},!0,[]));let c,d;void 0!==n.apu&&(c=b(n.apu)),void 0!==n.apv&&(d=b(n.apv));const p=await B(s,t,"ECDH-ES"===e?n.enc:e,parseInt(e.substr(-5,3),10)||U.get(n.enc),c,d);if("ECDH-ES"===e)return p;le(a);const h=e.substr(-6);return T(h,p,a)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return le(a),(async(e,t,a)=>{if(F(e,t),t.usages.includes("decrypt"))return new Uint8Array(await r.subtle.decrypt(N(e),t,a));if(t.usages.includes("unwrapKey")){const n=await r.subtle.unwrapKey("raw",a,t,N(e),...R);return new Uint8Array(await r.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(e,t,a);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{le(a),we(n,"p2c","PBES2 Count"),we(n,"p2s","PBES2 Salt");const{p2c:r}=n,i=b(n.p2s);return z(e,t,a,r,i)}case"A128KW":case"A192KW":case"A256KW":return le(a),T(e,t,a);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":le(a),we(n,"iv","Initialization Vector"),we(n,"tag","Authentication Tag");return(async(e,t,r,a,n)=>{const i=e.substr(0,7);return V(i,t,r,a,n,new Uint8Array(0))})(e,t,a,b(n.iv),b(n.tag));default:throw new i('unsupported or invalid "alg" (JWE Algorithm) header value')}var o}const me=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)},ge=J(h),Ae=Z.bind(void 0,s,new Map),Ee=me.bind(void 0,"keyManagementAlgorithms"),Se=me.bind(void 0,"contentEncryptionAlgorithms");async function be(e,t,r){var a;if(!ne(e))throw new s("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new s("JOSE Header missing");if("string"!=typeof e.iv)throw new s("JWE Initialization Vector missing or incorrect type");if("string"!=typeof e.ciphertext)throw new s("JWE Ciphertext missing or incorrect type");if("string"!=typeof e.tag)throw new s("JWE Authentication Tag missing or incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new s("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new s("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new s("JWE AAD incorrect type");if(void 0!==e.header&&!ne(e.header))throw new s("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!ne(e.unprotected))throw new s("JWE Per-Recipient Unprotected Header incorrect type");let o;if(e.protected){const t=b(e.protected);o=JSON.parse(u.decode(t))}if(!Q(o,e.header,e.unprotected))throw new s("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const c={...o,...e.header,...e.unprotected};if(Ae(null==r?void 0:r.crit,o,c),void 0!==c.zip){if(!o||!o.zip)throw new s('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==c.zip)throw new i('unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:d,enc:p}=c;if("string"!=typeof d||!d)throw new s("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof p||!p)throw new s("missing JWE Encryption Algorithm (enc) in JWE Header");const h=r&&Ee(r.keyManagementAlgorithms),l=r&&Se(r.contentEncryptionAlgorithms);if(h&&!h.has(d))throw new n('"alg" (Algorithm) Header Parameter not allowed');if(l&&!l.has(p))throw new n('"enc" (Encryption Algorithm) Header Parameter not allowed');let f,m;void 0!==e.encrypted_key&&(f=b(e.encrypted_key)),"function"==typeof t&&(t=await t(o,e));try{m=await fe(d,t,f,c)}catch(e){if(e instanceof TypeError)throw e;m=ge(p)}const g=b(e.iv),A=b(e.tag),E=y.encode(null!==(a=e.protected)&&void 0!==a?a:"");let S;S=void 0!==e.aad?w(E,y.encode("."),y.encode(e.aad)):E;let v=await V(p,m,b(e.ciphertext),g,A,S);"DEF"===c.zip&&(v=await((null==r?void 0:r.inflateRaw)||k)(v));const H={plaintext:v};return void 0!==e.protected&&(H.protectedHeader=o),void 0!==e.aad&&(H.additionalAuthenticatedData=b(e.aad)),void 0!==e.unprotected&&(H.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(H.unprotectedHeader=e.header),H}async function ve(e,t,r){if(e instanceof Uint8Array&&(e=u.decode(e)),"string"!=typeof e)throw new s("Compact JWE must be a string or Uint8Array");const{0:a,1:n,2:i,3:o,4:c,length:d}=e.split(".");if(5!==d)throw new s("Invalid Compact JWE");const p=await be({ciphertext:o||void 0,iv:i||void 0,protected:a||void 0,tag:c||void 0,encrypted_key:n||void 0},t,r);return{plaintext:p.plaintext,protectedHeader:p.protectedHeader}}const He=Z.bind(void 0,c,new Map([["b64",!0]])),Ce=me.bind(void 0,"algorithms");async function Pe(e,t,a){var i;if(!ne(e))throw new c("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new c('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new c("JWS Protected Header incorrect type");if(void 0===e.payload)throw new c("JWS Payload missing");if("string"!=typeof e.signature)throw new c("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ne(e.header))throw new c("JWS Unprotected Header incorrect type");let o={};if(e.protected){const t=b(e.protected);o=JSON.parse(u.decode(t))}if(!Q(o,e.header))throw new c("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const s={...o,...e.header};let d=!0;if(He(null==a?void 0:a.crit,o,s).has("b64")&&(d=o.b64,"boolean"!=typeof d))throw new c('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:h}=s;if("string"!=typeof h||!h)throw new c('JWS "alg" (Algorithm) Header Parameter missing or invalid');const l=a&&Ce(a.algorithms);if(l&&!l.has(h))throw new n('"alg" (Algorithm) Header Parameter not allowed');if(d){if("string"!=typeof e.payload)throw new c("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new c("JWS Payload must be a string or an Uint8Array instance");"function"==typeof t&&(t=await t(o,e)),de(h,t);const f=w(y.encode(null!==(i=e.protected)&&void 0!==i?i:""),y.encode("."),"string"==typeof e.payload?y.encode(e.payload):e.payload),m=b(e.signature);if(!await(async(e,t,a,n)=>{let i;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError("symmetric keys are only applicable for HMAC-based algorithms");i=await r.subtle.importKey("raw",t,{hash:{name:`SHA-${e.substr(-3)}`},name:"HMAC"},!1,["verify"])}else i=t;F(e,i);const o=ce(e);try{return await r.subtle.verify(o,i,a,n)}catch(e){return!1}})(h,t,m,f))throw new p;let g;g=d?b(e.payload):"string"==typeof e.payload?y.encode(e.payload):e.payload;const A={payload:g};return void 0!==e.protected&&(A.protectedHeader=o),void 0!==e.header&&(A.unprotectedHeader=e.header),A}async function Ke(e,t,r){if(e instanceof Uint8Array&&(e=u.decode(e)),"string"!=typeof e)throw new c("Compact JWS must be a string or Uint8Array");const{0:a,1:n,2:i,length:o}=e.split(".");if(3!==o)throw new c("Invalid Compact JWS");const s=await Pe({payload:n||void 0,protected:a||void 0,signature:i||void 0},t,r);return{payload:s.payload,protectedHeader:s.protectedHeader}}const _e=async(e,t)=>{const{payload:r}=await Ke(t,e).catch((e=>{throw new Error(`PoR: ${String(e)}`)}));return JSON.parse((new TextDecoder).decode(r).toString())},ke=async(e,t)=>{const{payload:r}=await Ke(t,e).catch((e=>{throw new Error("PoO "+String(e))}));return JSON.parse((new TextDecoder).decode(r).toString())},We=async(e,t)=>{const r=new TextDecoder,a=await se(t,"A256GCM"),{plaintext:n}=await ve(e,a);return r.decode(n)},Ue="ES256",Je=async(e,t)=>{const r=(new TextEncoder).encode(JSON.stringify(t));return await new ye(r).setProtectedHeader({alg:Ue}).sign(e)};return e.SIGNING_ALG=Ue,e.createBlockchainProof=async(e,t,r,a)=>{const n=await ke(e,t);return{privateStorage:{availability:"privateStorage",permissions:{view:[n.exchange.orig,n.exchange.dest]},type:"dict",id:n.exchange.id,content:{[n.exchange.block_id]:{poO:t,poR:r}}},blockchain:{availability:"blockchain",type:"jwk",content:{[a.kid]:a}}}},e.createJwk=async()=>{let e;e=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);const t=await v(e),r=await async function(e,t="sha256"){if(!ne(e))throw new TypeError("JWK must be an object");let r;switch(e.kty){case"EC":ie(e.crv,'"crv" (Curve) Parameter'),ie(e.x,'"x" (X Coordinate) Parameter'),ie(e.y,'"y" (Y Coordinate) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":ie(e.crv,'"crv" (Subtype of Key Pair) Parameter'),ie(e.x,'"x" (Public Key) Parameter'),r={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":ie(e.e,'"e" (Exponent) Parameter'),ie(e.n,'"n" (Modulus) Parameter'),r={e:e.e,kty:e.kty,n:e.n};break;case"oct":ie(e.k,'"k" (Key Value) Parameter'),r={k:e.k,kty:e.kty};break;default:throw new i('"kty" (Key Type) Parameter missing or unsupported')}const a=y.encode(JSON.stringify(r));return S(await D(t,a))}(t);return t.kid=r,t.alg="A256GCM",t},e.createPoO=async(e,t,r,a,n,i,o)=>{const s="string"==typeof t?(new TextEncoder).encode(t):new Uint8Array(t),c=await se(o),d=await new ae(s).setProtectedHeader({alg:"dir",enc:"A256GCM"}).encrypt(c),p=await ue(d),h=await ue(s),y=await ue(JSON.stringify(o)),u={iss:r,sub:a,iat:Date.now(),exchange:{id:n,orig:r,dest:a,block_id:i,block_desc:"description",hash_alg:"sha256",cipherblock_dgst:p,block_commitment:h,key_commitment:y}};return{cipherblock:d,poO:await Je(e,u)}},e.createPoR=async(e,t,r,a,n)=>{const i=await ue(t),o={iss:r,sub:a,iat:Date.now(),exchange:{poo_dgst:i,hash_alg:"sha256",exchangeId:n}};return await Je(e,o)},e.decodePoo=ke,e.decodePor=_e,e.decryptCipherblock=We,e.sha=ue,e.signProof=Je,e.validateCipherblock=async(e,t,r,a)=>{const n=await We(t,r);if(await ue(n)===a.exchange.block_commitment)return!0;throw new Error("hashed CipherBlock not correspond to block_commitment parameter included in the proof of origin")},e.validatePoO=async(e,t,r)=>{const a=await ke(e,t),n=await ue(r);if(a.exchange.cipherblock_dgst!==n)throw new Error("the cipherblock_dgst parameter in the proof of origin does not correspond to hash of the cipherblock received by the provider");if(Date.now()-a.iat>5e3)throw new Error("timestamp error");return!0},e.validatePoP=async(e,t,r,a,n)=>{await Ke(r,e).catch((e=>{throw new Error("PoP "+String(e))}));const i=await ke(t,n),o=await ue(JSON.stringify(a));if(i.exchange.key_commitment===o)return!0;throw new Error("hashed key not correspond to poO key_commitment parameter")},e.validatePoR=async(e,t,r)=>{const a=await _e(e,t);if(await ue(r)!==a.exchange.poo_dgst)throw new Error("the hashed proof of origin received does not correspond to the poo_dgst parameter in the proof of origin");if(Date.now()-a.iat>5e3)throw new Error("timestamp error");return!0},Object.defineProperty(e,"__esModule",{value:!0}),e}({});
