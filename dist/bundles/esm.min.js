const e=new TextEncoder,t=new TextDecoder;function r(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let a=0;return e.forEach((e=>{r.set(e,a),a+=e.length})),r}function a(e,t,r){if(t<0||t>=4294967296)throw new RangeError(`value must be >= 0 and <= 4294967295. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function n(e){const t=Math.floor(e/4294967296),r=e%4294967296,n=new Uint8Array(8);return a(n,t,0),a(n,r,4),n}function i(e){const t=new Uint8Array(4);return a(t,e),t}function o(e){return r(i(e.length),e)}const s=t=>(t=>{let r=t;"string"==typeof r&&(r=e.encode(r));const a=[];for(let e=0;e<r.length;e+=32768)a.push(String.fromCharCode.apply(null,r.subarray(e,e+32768)));return btoa(a.join(""))})(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),c=e=>{let r=e;r instanceof Uint8Array&&(r=t.decode(r)),r=r.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>new Uint8Array(atob(e).split("").map((e=>e.charCodeAt(0)))))(r)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class d extends Error{constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}static get code(){return"ERR_JOSE_GENERIC"}}class h extends d{constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=t,this.reason=r}static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}}class p extends d{constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=t,this.reason=r}static get code(){return"ERR_JWT_EXPIRED"}}class u extends d{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class l extends d{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class y extends d{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class w extends d{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class f extends d{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class g extends d{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class m extends d{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}static get code(){return"ERR_JWK_INVALID"}}class E extends d{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var A=crypto;function b(e){try{return null!=e&&"boolean"==typeof e.extractable&&"string"==typeof e.algorithm.name&&"string"==typeof e.type}catch(e){return!1}}var S=A.getRandomValues.bind(A);function v(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new l(`Unsupported JWE Algorithm: ${e}`)}}var H=e=>S(new Uint8Array(v(e)>>3));const k=(e,t)=>{if(t.length<<3!==v(e))throw new w("Invalid Initialization Vector length")},P=(e,t)=>{if(e.length<<3!==t)throw new w("Invalid Content Encryption Key length")};function C(){return"function"==typeof WebSocketPair}function _(){try{return void 0!==process.versions.node}catch(e){return!1}}function K(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function W(e,t){return e.name===t}function J(e){return parseInt(e.name.substr(4),10)}function O(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function R(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!W(e.algorithm,"HMAC"))throw K("HMAC");const r=parseInt(t.substr(2),10);if(J(e.algorithm.hash)!==r)throw K(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!W(e.algorithm,"RSASSA-PKCS1-v1_5"))throw K("RSASSA-PKCS1-v1_5");const r=parseInt(t.substr(2),10);if(J(e.algorithm.hash)!==r)throw K(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!W(e.algorithm,"RSA-PSS"))throw K("RSA-PSS");const r=parseInt(t.substr(2),10);if(J(e.algorithm.hash)!==r)throw K(`SHA-${r}`,"algorithm.hash");break}case _()&&"EdDSA":if("NODE-ED25519"!==e.algorithm.name&&"NODE-ED448"!==e.algorithm.name)throw K("NODE-ED25519 or NODE-ED448");break;case C()&&"EdDSA":if(!W(e.algorithm,"NODE-ED25519"))throw K("NODE-ED25519");break;case"ES256":case"ES384":case"ES512":{if(!W(e.algorithm,"ECDSA"))throw K("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw K(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}O(e,r)}function T(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!W(e.algorithm,"AES-GCM"))throw K("AES-GCM");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw K(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!W(e.algorithm,"AES-KW"))throw K("AES-KW");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw K(r,"algorithm.length");break}case"ECDH-ES":if(!W(e.algorithm,"ECDH"))throw K("ECDH");break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!W(e.algorithm,"PBKDF2"))throw K("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!W(e.algorithm,"RSA-OAEP"))throw K("RSA-OAEP");const r=parseInt(t.substr(9),10)||1;if(J(e.algorithm.hash)!==r)throw K(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}O(e,r)}var D=(e,...t)=>{let r="Key must be ";if(t.length>2){const e=t.pop();r+=`one of type ${t.join(", ")}, or ${e}.`}else 2===t.length?r+=`one of type ${t[0]} or ${t[1]}.`:r+=`of type ${t[0]}.`;return null==e?r+=` Received ${e}`:"function"==typeof e&&e.name?r+=` Received function ${e.name}`:"object"==typeof e&&null!=e&&e.constructor&&e.constructor.name&&(r+=` Received an instance of ${e.constructor.name}`),r},U=e=>b(e);const x=["CryptoKey"];async function I(e,t,a,i,o,s){if(!(t instanceof Uint8Array))throw new TypeError(D(t,"Uint8Array"));const c=parseInt(e.substr(1,3),10),d=await A.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),h=await A.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),p=r(s,i,a,n(s.length<<3)),u=new Uint8Array((await A.subtle.sign("HMAC",h,p)).slice(0,c>>3));let l,w;try{l=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let a=0,n=-1;for(;++n<r;)a|=e[n]^t[n];return 0===a})(o,u)}catch(e){}if(!l)throw new y;try{w=new Uint8Array(await A.subtle.decrypt({iv:i,name:"AES-CBC"},d,a))}catch(e){}if(!w)throw new y;return w}const M=async(e,t,a,n,i,o)=>{if(!(b(t)||t instanceof Uint8Array))throw new TypeError(D(t,...x,"Uint8Array"));switch(k(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&P(t,parseInt(e.substr(-3),10)),I(e,t,a,n,i,o);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&P(t,parseInt(e.substr(1,3),10)),async function(e,t,a,n,i,o){let s;t instanceof Uint8Array?s=await A.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(T(t,e,"decrypt"),s=t);try{return new Uint8Array(await A.subtle.decrypt({additionalData:o,iv:n,name:"AES-GCM",tagLength:128},s,r(a,i)))}catch(e){throw new y}}(e,t,a,n,i,o);default:throw new l("Unsupported JWE Content Encryption Algorithm")}},$=async()=>{throw new l('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.')},N=async()=>{throw new l('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.')},j=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function B(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const G=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function L(e,t){if(e.algorithm.length!==parseInt(t.substr(1,3),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function z(e,t,r){if(b(e))return T(e,t,r),e;if(e instanceof Uint8Array)return A.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(D(e,...x,"Uint8Array"))}const V=async(e,t,r)=>{const a=await z(t,e,"wrapKey");L(a,e);const n=await A.subtle.importKey("raw",r,...G);return new Uint8Array(await A.subtle.wrapKey("raw",n,a,"AES-KW"))},F=async(e,t,r)=>{const a=await z(t,e,"unwrapKey");L(a,e);const n=await A.subtle.unwrapKey("raw",r,a,"AES-KW",...G);return new Uint8Array(await A.subtle.exportKey("raw",n))},Y=async(e,t)=>{const r=`SHA-${e.substr(-3)}`;return new Uint8Array(await A.subtle.digest(r,t))},q=async(t,a,n,s,c=new Uint8Array(0),d=new Uint8Array(0))=>{if(!b(t))throw new TypeError(D(t,...x));if(T(t,"ECDH-ES"),!b(a))throw new TypeError(D(a,...x));T(a,"ECDH-ES","deriveBits","deriveKey");const h=r(o(e.encode(n)),o(c),o(d),i(s));if(!a.usages.includes("deriveBits"))throw new TypeError('ECDH-ES private key "usages" must include "deriveBits"');const p=new Uint8Array(await A.subtle.deriveBits({name:"ECDH",public:t},a,Math.ceil(parseInt(a.algorithm.namedCurve.substr(-3),10)/8)<<3));return async function(e,t,a,n){const o=Math.ceil((a>>3)/32);let s;for(let a=1;a<=o;a++){const o=new Uint8Array(4+t.length+n.length);o.set(i(a)),o.set(t,4),o.set(n,4+t.length),s=s?r(s,await e("sha256",o)):await e("sha256",o)}return s=s.slice(0,a>>3),s}(Y,p,s,h)},X=e=>{if(!b(e))throw new TypeError(D(e,...x));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)};async function Z(t,a,n,i){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new w("PBES2 Salt Input must be 8 or more octets")}(t);const o=function(t,a){return r(e.encode(t),new Uint8Array([0]),a)}(a,t),s=parseInt(a.substr(13,3),10),c={hash:`SHA-${a.substr(8,3)}`,iterations:n,name:"PBKDF2",salt:o},d={length:s,name:"AES-KW"},h=await function(e,t){if(e instanceof Uint8Array)return A.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(b(e))return T(e,t,"deriveBits","deriveKey"),e;throw new TypeError(D(e,...x,"Uint8Array"))}(i,a);if(h.usages.includes("deriveBits"))return new Uint8Array(await A.subtle.deriveBits(c,h,s));if(h.usages.includes("deriveKey"))return A.subtle.deriveKey(c,h,d,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}function Q(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new l(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var ee=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function te(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new l(`Unsupported JWE Algorithm: ${e}`)}}var re=e=>S(new Uint8Array(te(e)>>3));var ae=async e=>{var t,r;const{algorithm:a,keyUsages:n}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.substr(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new l(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.substr(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case(C()||_())&&"OKP":if("EdDSA"!==e.alg)throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');switch(e.crv){case"Ed25519":t={name:"NODE-ED25519",namedCurve:"NODE-ED25519"},r=e.d?["sign"]:["verify"];break;case _()&&"Ed448":t={name:"NODE-ED448",namedCurve:"NODE-ED448"},r=e.d?["sign"]:["verify"];break;default:throw new l('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value')}break;default:throw new l('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),i=[a,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:n];if("PBKDF2"===a.name)return A.subtle.importKey("raw",c(e.k),...i);const o={...e};return delete o.alg,A.subtle.importKey("jwk",o,...i)};async function ne(e,t,r){if(!B(e))throw new TypeError("JWK must be an object");if(t||(t=e.alg),"string"!=typeof t||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?ae({...e,alg:t,ext:!1}):c(e.k);case"RSA":if(void 0!==e.oth)throw new l('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return ae({...e,alg:t});default:throw new l('Unsupported "kty" (Key Type) Parameter value')}}const ie=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?(e=>{if(!(e instanceof Uint8Array)){if(!U(e))throw new TypeError(D(e,...x,"Uint8Array"));if("secret"!==e.type)throw new TypeError(`${x.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(t):((e,t)=>{if(!U(e))throw new TypeError(D(e,...x));if("secret"===e.type)throw new TypeError(`${x.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===t&&"public"===e.type)throw new TypeError(`${x.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===t&&"public"===e.type)throw new TypeError(`${x.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(e.algorithm&&"verify"===t&&"private"===e.type)throw new TypeError(`${x.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(e.algorithm&&"encrypt"===t&&"private"===e.type)throw new TypeError(`${x.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(t,r)};const oe=async(e,t,a,i,o)=>{if(!(b(a)||a instanceof Uint8Array))throw new TypeError(D(a,...x,"Uint8Array"));switch(k(e,i),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a instanceof Uint8Array&&P(a,parseInt(e.substr(-3),10)),async function(e,t,a,i,o){if(!(a instanceof Uint8Array))throw new TypeError(D(a,"Uint8Array"));const s=parseInt(e.substr(1,3),10),c=await A.subtle.importKey("raw",a.subarray(s>>3),"AES-CBC",!1,["encrypt"]),d=await A.subtle.importKey("raw",a.subarray(0,s>>3),{hash:"SHA-"+(s<<1),name:"HMAC"},!1,["sign"]),h=new Uint8Array(await A.subtle.encrypt({iv:i,name:"AES-CBC"},c,t)),p=r(o,i,h,n(o.length<<3));return{ciphertext:h,tag:new Uint8Array((await A.subtle.sign("HMAC",d,p)).slice(0,s>>3))}}(e,t,a,i,o);case"A128GCM":case"A192GCM":case"A256GCM":return a instanceof Uint8Array&&P(a,parseInt(e.substr(1,3),10)),async function(e,t,r,a,n){let i;r instanceof Uint8Array?i=await A.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(T(r,e,"encrypt"),i=r);const o=new Uint8Array(await A.subtle.encrypt({additionalData:n,iv:a,name:"AES-GCM",tagLength:128},i,t)),s=o.slice(-16);return{ciphertext:o.slice(0,-16),tag:s}}(e,t,a,i,o);default:throw new l("Unsupported JWE Content Encryption Algorithm")}};async function se(e,t,r,a){switch(ie(e,t,"decrypt"),e){case"dir":if(void 0!==r)throw new w("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new w("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!B(a.epk))throw new w('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!X(t))throw new l("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const n=await ne(a.epk,e);let i,o;if(void 0!==a.apu){if("string"!=typeof a.apu)throw new w('JOSE Header "apu" (Agreement PartyUInfo) invalid');i=c(a.apu)}if(void 0!==a.apv){if("string"!=typeof a.apv)throw new w('JOSE Header "apv" (Agreement PartyVInfo) invalid');o=c(a.apv)}const s=await q(n,t,"ECDH-ES"===e?a.enc:e,"ECDH-ES"===e?te(a.enc):parseInt(e.substr(-5,3),10),i,o);if("ECDH-ES"===e)return s;if(void 0===r)throw new w("JWE Encrypted Key missing");return F(e.substr(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new w("JWE Encrypted Key missing");return(async(e,t,r)=>{if(!b(t))throw new TypeError(D(t,...x));if(T(t,e,"decrypt","unwrapKey"),ee(e,t),t.usages.includes("decrypt"))return new Uint8Array(await A.subtle.decrypt(Q(e),t,r));if(t.usages.includes("unwrapKey")){const a=await A.subtle.unwrapKey("raw",r,t,Q(e),...G);return new Uint8Array(await A.subtle.exportKey("raw",a))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(void 0===r)throw new w("JWE Encrypted Key missing");if("number"!=typeof a.p2c)throw new w('JOSE Header "p2c" (PBES2 Count) missing or invalid');if("string"!=typeof a.p2s)throw new w('JOSE Header "p2s" (PBES2 Salt) missing or invalid');return(async(e,t,r,a,n)=>{const i=await Z(n,e,a,t);return F(e.substr(-6),i,r)})(e,t,r,a.p2c,c(a.p2s));case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new w("JWE Encrypted Key missing");return F(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":if(void 0===r)throw new w("JWE Encrypted Key missing");if("string"!=typeof a.iv)throw new w('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof a.tag)throw new w('JOSE Header "tag" (Authentication Tag) missing or invalid');return async function(e,t,r,a,n){const i=e.substr(0,7);return M(i,t,r,a,n,new Uint8Array(0))}(e,t,r,c(a.iv),c(a.tag));default:throw new l('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function ce(e,t,r,a,n){if(void 0!==n.crit&&void 0===a.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!a||void 0===a.crit)return new Set;if(!Array.isArray(a.crit)||0===a.crit.length||a.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;i=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of a.crit){if(!i.has(t))throw new l(`Extension Header Parameter "${t}" is not recognized`);if(void 0===n[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(i.get(t)&&void 0===a[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(a.crit)}const de=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function he(a,n,i){var o;if(!B(a))throw new w("Flattened JWE must be an object");if(void 0===a.protected&&void 0===a.header&&void 0===a.unprotected)throw new w("JOSE Header missing");if("string"!=typeof a.iv)throw new w("JWE Initialization Vector missing or incorrect type");if("string"!=typeof a.ciphertext)throw new w("JWE Ciphertext missing or incorrect type");if("string"!=typeof a.tag)throw new w("JWE Authentication Tag missing or incorrect type");if(void 0!==a.protected&&"string"!=typeof a.protected)throw new w("JWE Protected Header incorrect type");if(void 0!==a.encrypted_key&&"string"!=typeof a.encrypted_key)throw new w("JWE Encrypted Key incorrect type");if(void 0!==a.aad&&"string"!=typeof a.aad)throw new w("JWE AAD incorrect type");if(void 0!==a.header&&!B(a.header))throw new w("JWE Shared Unprotected Header incorrect type");if(void 0!==a.unprotected&&!B(a.unprotected))throw new w("JWE Per-Recipient Unprotected Header incorrect type");let s;if(a.protected){const e=c(a.protected);try{s=JSON.parse(t.decode(e))}catch(e){throw new w("JWE Protected Header is invalid")}}if(!j(s,a.header,a.unprotected))throw new w("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const d={...s,...a.header,...a.unprotected};if(ce(w,new Map,null==i?void 0:i.crit,s,d),void 0!==d.zip){if(!s||!s.zip)throw new w('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==d.zip)throw new l('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:h,enc:p}=d;if("string"!=typeof h||!h)throw new w("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof p||!p)throw new w("missing JWE Encryption Algorithm (enc) in JWE Header");const y=i&&de("keyManagementAlgorithms",i.keyManagementAlgorithms),f=i&&de("contentEncryptionAlgorithms",i.contentEncryptionAlgorithms);if(y&&!y.has(h))throw new u('"alg" (Algorithm) Header Parameter not allowed');if(f&&!f.has(p))throw new u('"enc" (Encryption Algorithm) Header Parameter not allowed');let g;void 0!==a.encrypted_key&&(g=c(a.encrypted_key));let m,E=!1;"function"==typeof n&&(n=await n(s,a),E=!0);try{m=await se(h,n,g,d)}catch(e){if(e instanceof TypeError)throw e;m=re(p)}const A=c(a.iv),b=c(a.tag),S=e.encode(null!==(o=a.protected)&&void 0!==o?o:"");let v;v=void 0!==a.aad?r(S,e.encode("."),e.encode(a.aad)):S;let H=await M(p,m,c(a.ciphertext),A,b,v);"DEF"===d.zip&&(H=await((null==i?void 0:i.inflateRaw)||$)(H));const k={plaintext:H};return void 0!==a.protected&&(k.protectedHeader=s),void 0!==a.aad&&(k.additionalAuthenticatedData=c(a.aad)),void 0!==a.unprotected&&(k.sharedUnprotectedHeader=a.unprotected),void 0!==a.header&&(k.unprotectedHeader=a.header),E?{...k,key:n}:k}var pe=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:s(e)};if(!b(e))throw new TypeError(D(e,...x,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:r,alg:a,use:n,...i}=await A.subtle.exportKey("jwk",e);return i};async function ue(e){return pe(e)}async function le(e,t,r,a,n={}){let i,o,c;switch(ie(e,r,"encrypt"),e){case"dir":c=r;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!X(r))throw new l("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const{apu:d,apv:h}=n;let{epk:p}=n;p||(p=await(async e=>{if(!b(e))throw new TypeError(D(e,...x));return(await A.subtle.generateKey({name:"ECDH",namedCurve:e.algorithm.namedCurve},!0,["deriveBits"])).privateKey})(r));const{x:u,y:y,crv:w,kty:f}=await ue(p),g=await q(r,p,"ECDH-ES"===e?t:e,"ECDH-ES"===e?te(t):parseInt(e.substr(-5,3),10),d,h);if(o={epk:{x:u,y:y,crv:w,kty:f}},d&&(o.apu=s(d)),h&&(o.apv=s(h)),"ECDH-ES"===e){c=g;break}c=a||re(t);const m=e.substr(-6);i=await V(m,g,c);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":c=a||re(t),i=await(async(e,t,r)=>{if(!b(t))throw new TypeError(D(t,...x));if(T(t,e,"encrypt","wrapKey"),ee(e,t),t.usages.includes("encrypt"))return new Uint8Array(await A.subtle.encrypt(Q(e),t,r));if(t.usages.includes("wrapKey")){const a=await A.subtle.importKey("raw",r,...G);return new Uint8Array(await A.subtle.wrapKey("raw",a,t,Q(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,r,c);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{c=a||re(t);const{p2c:d,p2s:h}=n;({encryptedKey:i,...o}=await(async(e,t,r,a=Math.floor(2049*Math.random())+2048,n=S(new Uint8Array(16)))=>{const i=await Z(n,e,a,t);return{encryptedKey:await V(e.substr(-6),i,r),p2c:a,p2s:s(n)}})(e,r,c,d,h));break}case"A128KW":case"A192KW":case"A256KW":c=a||re(t),i=await V(e,r,c);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{c=a||re(t);const{iv:d}=n;({encryptedKey:i,...o}=await async function(e,t,r,a){const n=e.substr(0,7);a||(a=H(n));const{ciphertext:i,tag:o}=await oe(n,r,t,a,new Uint8Array(0));return{encryptedKey:i,iv:s(a),tag:s(o)}}(e,r,c,d));break}default:throw new l('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:c,encryptedKey:i,parameters:o}}const ye=Symbol();class we{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(a,n){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new w("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!j(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new w("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const i={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(ce(w,new Map,null==n?void 0:n.crit,this._protectedHeader,i),void 0!==i.zip){if(!this._protectedHeader||!this._protectedHeader.zip)throw new w('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==i.zip)throw new l('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:o,enc:c}=i;if("string"!=typeof o||!o)throw new w('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof c||!c)throw new w('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let d,h,p,u,y,f,g;if("dir"===o){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if("ECDH-ES"===o&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");{let e;({cek:h,encryptedKey:d,parameters:e}=await le(o,c,a,this._cek,this._keyManagementParameters)),e&&(n&&ye in n?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...e}:this.setUnprotectedHeader(e):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...e}:this.setProtectedHeader(e))}if(this._iv||(this._iv=H(c)),u=this._protectedHeader?e.encode(s(JSON.stringify(this._protectedHeader))):e.encode(""),this._aad?(y=s(this._aad),p=r(u,e.encode("."),e.encode(y))):p=u,"DEF"===i.zip){const e=await((null==n?void 0:n.deflateRaw)||N)(this._plaintext);({ciphertext:f,tag:g}=await oe(c,e,h,this._iv,p))}else({ciphertext:f,tag:g}=await oe(c,this._plaintext,h,this._iv,p));const m={ciphertext:s(f),iv:s(this._iv),tag:s(g)};return d&&(m.encrypted_key=s(d)),y&&(m.aad=y),this._protectedHeader&&(m.protected=t.decode(u)),this._sharedUnprotectedHeader&&(m.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(m.header=this._unprotectedHeader),m}}function fe(e,t){const r=parseInt(e.substr(-3),10);switch(e){case"HS256":case"HS384":case"HS512":return{hash:`SHA-${r}`,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:`SHA-${r}`,name:"RSA-PSS",saltLength:r>>3};case"RS256":case"RS384":case"RS512":return{hash:`SHA-${r}`,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:`SHA-${r}`,name:"ECDSA",namedCurve:t};case(C()||_())&&"EdDSA":return{name:t,namedCurve:t};default:throw new l(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function ge(e,t,r){if(b(t))return R(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(D(t,...x));return A.subtle.importKey("raw",t,{hash:`SHA-${e.substr(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(D(t,...x,"Uint8Array"))}async function me(a,n,i){var o;if(!B(a))throw new f("Flattened JWS must be an object");if(void 0===a.protected&&void 0===a.header)throw new f('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==a.protected&&"string"!=typeof a.protected)throw new f("JWS Protected Header incorrect type");if(void 0===a.payload)throw new f("JWS Payload missing");if("string"!=typeof a.signature)throw new f("JWS Signature missing or incorrect type");if(void 0!==a.header&&!B(a.header))throw new f("JWS Unprotected Header incorrect type");let s={};if(a.protected){const e=c(a.protected);try{s=JSON.parse(t.decode(e))}catch(e){throw new f("JWS Protected Header is invalid")}}if(!j(s,a.header))throw new f("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const d={...s,...a.header};let h=!0;if(ce(f,new Map([["b64",!0]]),null==i?void 0:i.crit,s,d).has("b64")&&(h=s.b64,"boolean"!=typeof h))throw new f('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:p}=d;if("string"!=typeof p||!p)throw new f('JWS "alg" (Algorithm) Header Parameter missing or invalid');const l=i&&de("algorithms",i.algorithms);if(l&&!l.has(p))throw new u('"alg" (Algorithm) Header Parameter not allowed');if(h){if("string"!=typeof a.payload)throw new f("JWS Payload must be a string")}else if("string"!=typeof a.payload&&!(a.payload instanceof Uint8Array))throw new f("JWS Payload must be a string or an Uint8Array instance");let y=!1;"function"==typeof n&&(n=await n(s,a),y=!0),ie(p,n,"verify");const w=r(e.encode(null!==(o=a.protected)&&void 0!==o?o:""),e.encode("."),"string"==typeof a.payload?e.encode(a.payload):a.payload),g=c(a.signature),m=await(async(e,t,r,a)=>{const n=await ge(e,t,"verify");ee(e,n);const i=fe(e,n.algorithm.namedCurve);try{return await A.subtle.verify(i,n,r,a)}catch(e){return!1}})(p,n,g,w);if(!m)throw new E;let b;b=h?c(a.payload):"string"==typeof a.payload?e.encode(a.payload):a.payload;const S={payload:b};return void 0!==a.protected&&(S.protectedHeader=s),void 0!==a.header&&(S.unprotectedHeader=a.header),y?{...S,key:n}:S}var Ee=e=>Math.floor(e.getTime()/1e3);const Ae=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;var be=e=>{const t=Ae.exec(e);if(!t)throw new TypeError("Invalid time period format");const r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(60*r);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(3600*r);case"day":case"days":case"d":return Math.round(86400*r);case"week":case"weeks":case"w":return Math.round(604800*r);default:return Math.round(31557600*r)}};const Se=e=>e.toLowerCase().replace(/^application\//,"");var ve=(e,r,a={})=>{const{typ:n}=a;if(n&&("string"!=typeof e.typ||Se(e.typ)!==Se(n)))throw new h('unexpected "typ" JWT header value',"typ","check_failed");let i;try{i=JSON.parse(t.decode(r))}catch(e){}if(!B(i))throw new g("JWT Claims Set must be a top-level JSON object");const{issuer:o}=a;if(o&&!(Array.isArray(o)?o:[o]).includes(i.iss))throw new h('unexpected "iss" claim value',"iss","check_failed");const{subject:s}=a;if(s&&i.sub!==s)throw new h('unexpected "sub" claim value',"sub","check_failed");const{audience:c}=a;if(c&&(d=i.aud,u="string"==typeof c?[c]:c,!("string"==typeof d?u.includes(d):Array.isArray(d)&&u.some(Set.prototype.has.bind(new Set(d))))))throw new h('unexpected "aud" claim value',"aud","check_failed");var d,u;let l;switch(typeof a.clockTolerance){case"string":l=be(a.clockTolerance);break;case"number":l=a.clockTolerance;break;case"undefined":l=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:y}=a,w=Ee(y||new Date);if(void 0!==i.iat||a.maxTokenAge){if("number"!=typeof i.iat)throw new h('"iat" claim must be a number',"iat","invalid");if(void 0===i.exp&&i.iat>w+l)throw new h('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}if(void 0!==i.nbf){if("number"!=typeof i.nbf)throw new h('"nbf" claim must be a number',"nbf","invalid");if(i.nbf>w+l)throw new h('"nbf" claim timestamp check failed',"nbf","check_failed")}if(void 0!==i.exp){if("number"!=typeof i.exp)throw new h('"exp" claim must be a number',"exp","invalid");if(i.exp<=w-l)throw new p('"exp" claim timestamp check failed',"exp","check_failed")}if(a.maxTokenAge){const e=w-i.iat;if(e-l>("number"==typeof a.maxTokenAge?a.maxTokenAge:be(a.maxTokenAge)))throw new p('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(e<0-l)throw new h('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return i};async function He(e,r,a){var n;const i=await async function(e,r,a){if(e instanceof Uint8Array&&(e=t.decode(e)),"string"!=typeof e)throw new f("Compact JWS must be a string or Uint8Array");const{0:n,1:i,2:o,length:s}=e.split(".");if(3!==s)throw new f("Invalid Compact JWS");const c=await me({payload:i,protected:n,signature:o},r,a),d={payload:c.payload,protectedHeader:c.protectedHeader};return"function"==typeof r?{...d,key:c.key}:d}(e,r,a);if((null===(n=i.protectedHeader.crit)||void 0===n?void 0:n.includes("b64"))&&!1===i.protectedHeader.b64)throw new g("JWTs MUST NOT use unencoded payload");const o={payload:ve(i.protectedHeader,i.payload,a),protectedHeader:i.protectedHeader};return"function"==typeof r?{...o,key:i.key}:o}class ke{constructor(e){this._flattened=new we(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}class Pe{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(a,n){if(!this._protectedHeader&&!this._unprotectedHeader)throw new f("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!j(this._protectedHeader,this._unprotectedHeader))throw new f("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...this._protectedHeader,...this._unprotectedHeader};let o=!0;if(ce(f,new Map([["b64",!0]]),null==n?void 0:n.crit,this._protectedHeader,i).has("b64")&&(o=this._protectedHeader.b64,"boolean"!=typeof o))throw new f('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=i;if("string"!=typeof c||!c)throw new f('JWS "alg" (Algorithm) Header Parameter missing or invalid');ie(c,a,"sign");let d,h=this._payload;o&&(h=e.encode(s(h))),d=this._protectedHeader?e.encode(s(JSON.stringify(this._protectedHeader))):e.encode("");const p=r(d,e.encode("."),h),u=await(async(e,t,r)=>{const a=await ge(e,t,"sign");ee(e,a);const n=await A.subtle.sign(fe(e,a.algorithm.namedCurve),a,r);return new Uint8Array(n)})(c,a,p),l={signature:s(u),payload:""};return o&&(l.payload=t.decode(h)),this._unprotectedHeader&&(l.header=this._unprotectedHeader),this._protectedHeader&&(l.protected=t.decode(d)),l}}class Ce{constructor(e){this._flattened=new Pe(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}class _e{constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class Ke{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const r=new _e(this,e,t);return this._signatures.push(r),r}async sign(){if(!this._signatures.length)throw new f("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const r=this._signatures[t],a=new Pe(this._payload);a.setProtectedHeader(r.protectedHeader),a.setUnprotectedHeader(r.unprotectedHeader);const{payload:n,...i}=await a.sign(r.key,r.options);if(0===t)e.payload=n;else if(e.payload!==n)throw new f("inconsistent use of JWS Unencoded Payload Option (RFC7797)");e.signatures.push(i)}return e}}class We extends class{constructor(e){if(!B(e))throw new TypeError("JWT Claims Set MUST be an object");this._payload=e}setIssuer(e){return this._payload={...this._payload,iss:e},this}setSubject(e){return this._payload={...this._payload,sub:e},this}setAudience(e){return this._payload={...this._payload,aud:e},this}setJti(e){return this._payload={...this._payload,jti:e},this}setNotBefore(e){return this._payload="number"==typeof e?{...this._payload,nbf:e}:{...this._payload,nbf:Ee(new Date)+be(e)},this}setExpirationTime(e){return this._payload="number"==typeof e?{...this._payload,exp:e}:{...this._payload,exp:Ee(new Date)+be(e)},this}setIssuedAt(e){return this._payload=void 0===e?{...this._payload,iat:Ee(new Date)}:{...this._payload,iat:e},this}}{setProtectedHeader(e){return this._protectedHeader=e,this}async sign(t,r){var a;const n=new Ce(e.encode(JSON.stringify(this._payload)));if(n.setProtectedHeader(this._protectedHeader),Array.isArray(null===(a=this._protectedHeader)||void 0===a?void 0:a.crit)&&this._protectedHeader.crit.includes("b64")&&!1===this._protectedHeader.b64)throw new g("JWTs MUST NOT use unencoded payload");return n.sign(t,r)}}const Je=(e,t)=>{if("string"!=typeof e||!e)throw new m(`${t} missing or invalid`)};async function Oe(e,t){return async function(e,t){var r;let a,n,i;switch(e){case"HS256":case"HS384":case"HS512":a=parseInt(e.substr(-3),10),n={name:"HMAC",hash:`SHA-${a}`,length:a},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a=parseInt(e.substr(-3),10),S(new Uint8Array(a>>3));case"A128KW":case"A192KW":case"A256KW":a=parseInt(e.substring(1,4),10),n={name:"AES-KW",length:a},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":a=parseInt(e.substring(1,4),10),n={name:"AES-GCM",length:a},i=["encrypt","decrypt"];break;default:throw new l('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return A.subtle.generateKey(n,null!==(r=null==t?void 0:t.extractable)&&void 0!==r&&r,i)}(e,t)}function Re(e){{let t="";const r="0123456789abcdef";return(e=ArrayBuffer.isView(e)?new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)):new Uint8Array(e)).forEach((e=>{t+=r[e>>4]+r[15&e]})),t}}async function Te(e,t,r){const a=await ne(e,r),n=await ne(t,r),i=await function(e,t=!1){if(e<1)throw new RangeError("byteLength MUST be > 0");return new Promise((function(r,a){{const a=new Uint8Array(e);self.crypto.getRandomValues(a),t&&(a[0]=128|a[0]),r(a)}}))}(16),o=await new Ke(i).addSignature(n).setProtectedHeader({alg:t.alg}).sign(),{payload:s}=await async function(e,t,r){if(!B(e))throw new f("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(B))throw new f("JWS Signatures missing or incorrect type");for(const a of e.signatures)try{return await me({header:a.header,payload:e.payload,protected:a.protected,signature:a.signature},t,r)}catch(e){}throw new E}(o,a);if(Re(s)!==Re(i))throw new Error(`verified nonce ${Re(s)} does not meet the one challenged ${Re(i)}`)}async function De(e,t){const r=JSON.parse(e.dataExchange[e.iss]);await Te(r,t);const a=await ne(t),n=t.alg;if(void 0===n)throw new Error("Private key does not have the alg property:\n"+JSON.stringify(t,void 0,2));return await new We(e).setProtectedHeader({alg:n}).setIssuedAt().sign(a)}function Ue(e){return null!=e&&"object"==typeof e&&!Array.isArray(e)}function xe(e){return Ue(e)||Array.isArray(e)?Array.isArray(e)?e.map((e=>Array.isArray(e)||Ue(e)?xe(e):e)):Object.keys(e).sort().map((t=>[t,xe(e[t])])):e}function Ie(e){return JSON.stringify(xe(e))}async function Me(e,t,r,a){const n=await ne(t),i=await He(e,n,a),o=i.payload,s=o.dataExchange[o.iss];if(Ie(t)!==Ie(JSON.parse(s)))throw new Error(`The proof is issued by ${s} instead of ${JSON.stringify(t)}`);for(const e in r){if(void 0===o[e])throw new Error(`Expected key '${e}' not found in proof`);if("dataExchange"===e){const e=r.dataExchange;$e(o.dataExchange,e)}else if(Ie(r[e])!==Ie(o[e]))throw new Error(`Proof's ${e}: ${JSON.stringify(o[e],void 0,2)} does not meet provided value ${JSON.stringify(r[e],void 0,2)}`)}return i}function $e(e,t){const r=["id","orig","dest","hashAlg","cipherblockDgst","blockCommitment","blockCommitment","secretCommitment","schema"];for(const t of r)if("schema"!==t&&(void 0===e[t]||""===e[t]))throw new Error(`${t} is missing on dataExchange.\ndataExchange: ${JSON.stringify(e,void 0,2)}`);for(const r in t)if(Ie(t[r])!==Ie(e[r]))throw new Error(`dataExchange's ${r}: ${JSON.stringify(e[r],void 0,2)} does not meet expected value ${JSON.stringify(t[r],void 0,2)}`)}const Ne="SHA-256",je="RS256",Be="A256GCM";async function Ge(e,t,r){const a=await ne(r);return await new ke(t).setProtectedHeader({alg:"dir",enc:"A256GCM",exchangeId:e,kid:r.kid}).encrypt(a)}async function Le(e,r){const a=await ne(r);return await async function(e,r,a){if(e instanceof Uint8Array&&(e=t.decode(e)),"string"!=typeof e)throw new w("Compact JWE must be a string or Uint8Array");const{0:n,1:i,2:o,3:s,4:c,length:d}=e.split(".");if(5!==d)throw new w("Invalid Compact JWE");const h=await he({ciphertext:s||void 0,iv:o||void 0,protected:n||void 0,tag:c||void 0,encrypted_key:i||void 0},r,a),p={plaintext:h.plaintext,protectedHeader:h.protectedHeader};return"function"==typeof r?{...p,key:h.key}:p}(e,a,{contentEncryptionAlgorithms:["A256GCM"]})}async function ze(e,t="SHA-256"){const r=["SHA-1","SHA-256","SHA-384","SHA-512"];if(!r.includes(t))throw new RangeError(`Valid hash algorith values are any of ${JSON.stringify(r)}`);const a=new TextEncoder,n="string"==typeof e?a.encode(e).buffer:e;let i="";{const e=await crypto.subtle.digest(t,n),r="0123456789abcdef";new Uint8Array(e).forEach((e=>{i+=r[e>>4]+r[15&e]}))}return i}async function Ve(){const t=await Oe("A256GCM",{extractable:!0}),r=await ue(t),a=await async function(t,r="sha256"){if(!B(t))throw new TypeError("JWK must be an object");let a;switch(t.kty){case"EC":Je(t.crv,'"crv" (Curve) Parameter'),Je(t.x,'"x" (X Coordinate) Parameter'),Je(t.y,'"y" (Y Coordinate) Parameter'),a={crv:t.crv,kty:t.kty,x:t.x,y:t.y};break;case"OKP":Je(t.crv,'"crv" (Subtype of Key Pair) Parameter'),Je(t.x,'"x" (Public Key) Parameter'),a={crv:t.crv,kty:t.kty,x:t.x};break;case"RSA":Je(t.e,'"e" (Exponent) Parameter'),Je(t.n,'"n" (Modulus) Parameter'),a={e:t.e,kty:t.kty,n:t.n};break;case"oct":Je(t.k,'"k" (Key Value) Parameter'),a={k:t.k,kty:t.kty};break;default:throw new l('"kty" (Key Type) Parameter missing or unsupported')}const n=e.encode(JSON.stringify(a));return s(await Y(r,n))}(r);return r.kid=a,r.alg="A256GCM",r}class Fe{constructor(e,t,r,a,n){if(this.jwkPairOrig=t,this.publicJwkDest=r,void 0!==n)this.jwkPairOrig.privateJwk.alg=n,this.jwkPairOrig.publicJwk.alg=n,this.publicJwkDest.alg=n;else if(void 0===this.jwkPairOrig.privateJwk.alg||void 0===this.jwkPairOrig.publicJwk.alg||void 0===this.publicJwkDest.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');this.dataExchange={id:e,orig:JSON.stringify(this.jwkPairOrig.publicJwk),dest:JSON.stringify(this.publicJwkDest),hashAlg:"SHA-256"},this.block={raw:a},this.checked=!1}async init(){await Te(this.jwkPairOrig.publicJwk,this.jwkPairOrig.privateJwk),this.block.secret=await Ve();const e=JSON.stringify(this.block.secret);this.block.jwe=await Ge(this.dataExchange.id,this.block.raw,this.block.secret),this.dataExchange={...this.dataExchange,cipherblockDgst:await ze(this.block.jwe,this.dataExchange.hashAlg),blockCommitment:await ze(this.block.raw,this.dataExchange.hashAlg),secretCommitment:await ze(e,this.dataExchange.hashAlg)},this.checked=!0}async generatePoO(){this._checkInit();const e={proofType:"PoO",iss:"orig",dataExchange:this.dataExchange};return this.block.poo=await De(e,this.jwkPairOrig.privateJwk),this.block.poo}async verifyPoR(e){if(this._checkInit(),void 0===this.block?.poo)throw new Error("Cannot verify a PoR if not even a PoO have been created");const t={proofType:"PoR",iss:"dest",dataExchange:this.dataExchange,pooDgst:await ze(this.block.poo,this.dataExchange.hashAlg)},r=await Me(e,this.publicJwkDest,t);return this.block.por=e,r}async generatePoP(e){if(this._checkInit(),void 0===this.block?.por)throw new Error("Before computing a PoP, you have first to receive a verify a PoR");const t={proofType:"PoP",iss:"orig",dataExchange:this.dataExchange,porDgst:await ze(this.block.por,this.dataExchange.hashAlg),secret:JSON.stringify(this.block.secret),verificationCode:e};return this.block.pop=await De(t,this.jwkPairOrig.privateJwk),this.block.pop}_checkInit(){if(!this.checked)throw new Error("NOT INITIALIZED. Before calling any other method, initialize this instance of NonRepudiationOrig calling async method init()")}}class Ye{constructor(e,t,r){this.jwkPairDest=t,this.publicJwkOrig=r,this.dataExchange={id:e,orig:JSON.stringify(this.publicJwkOrig),dest:JSON.stringify(this.jwkPairDest.publicJwk),hashAlg:"SHA-256"},this.checked=!1}async init(){await Te(this.jwkPairDest.publicJwk,this.jwkPairDest.privateJwk),this.checked=!0}async verifyPoO(e,t){this._checkInit();const r={proofType:"PoO",iss:"orig",dataExchange:{...this.dataExchange,cipherblockDgst:await ze(t,this.dataExchange.hashAlg)}},a=await Me(e,this.publicJwkOrig,r);return this.block={jwe:t,poo:e},this.dataExchange=a.payload.dataExchange,a}async generatePoR(){if(this._checkInit(),void 0===this.block?.poo)throw new Error("Before computing a PoR, you have first to receive a valid cipherblock with a PoO and validate the PoO");const e={proofType:"PoR",iss:"dest",dataExchange:this.dataExchange,pooDgst:await ze(this.block.poo)};return this.block.por=await De(e,this.jwkPairDest.privateJwk),this.block.por}async verifyPoPAndDecrypt(e,t,r){if(this._checkInit(),void 0===this.block?.por)throw new Error("Cannot verify a PoP if not even a PoR have been created");const a=(await Le(this.block.jwe,JSON.parse(t))).plaintext;if(await ze(a)!==this.dataExchange.blockCommitment)throw new Error("Decrypted block does not meet the committed one");this.block.secret=JSON.parse(t),this.block.decrypted=a;const n={proofType:"PoP",iss:"orig",dataExchange:this.dataExchange,porDgst:await ze(this.block.por),secret:t,verificationCode:r},i=await Me(e,this.publicJwkOrig,n);return this.block.pop=e,{verified:i,decryptedBlock:a}}_checkInit(){if(!this.checked)throw new Error("NOT INITIALIZED. Before calling any other method, initialize this instance of NonRepudiationOrig calling async method init()")}}export{Be as ENC_ALG,Ne as HASH_ALG,Ye as NonRepudiationDest,Fe as NonRepudiationOrig,je as SIGNING_ALG,De as createProof,Le as jweDecrypt,Ge as jweEncrypt,Ve as oneTimeSecret,ze as sha,Te as verifyKeyPair,Me as verifyProof};
