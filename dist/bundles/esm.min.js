const e=new TextEncoder,t=new TextDecoder;function r(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let n=0;return e.forEach((e=>{r.set(e,n),n+=e.length})),r}function n(e,t,r){if(t<0||t>=4294967296)throw new RangeError(`value must be >= 0 and <= 4294967295. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function a(e){const t=Math.floor(e/4294967296),r=e%4294967296,a=new Uint8Array(8);return n(a,t,0),n(a,r,4),a}function o(e){const t=new Uint8Array(4);return n(t,e),t}function i(e){return r(o(e.length),e)}const s=t=>(t=>{let r=t;"string"==typeof r&&(r=e.encode(r));const n=[];for(let e=0;e<r.length;e+=32768)n.push(String.fromCharCode.apply(null,r.subarray(e,e+32768)));return btoa(n.join(""))})(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),c=e=>{let r=e;r instanceof Uint8Array&&(r=t.decode(r)),r=r.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>new Uint8Array(atob(e).split("").map((e=>e.charCodeAt(0)))))(r)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class d extends Error{constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}static get code(){return"ERR_JOSE_GENERIC"}}class p extends d{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class h extends d{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class y extends d{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class u extends d{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class w extends d{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class l extends d{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}static get code(){return"ERR_JWK_INVALID"}}class f extends d{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var g=crypto;function E(e){try{return null!=e&&"boolean"==typeof e.extractable&&"string"==typeof e.algorithm.name&&"string"==typeof e.type}catch(e){return!1}}var m=g.getRandomValues.bind(g);function A(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new h(`Unsupported JWE Algorithm: ${e}`)}}var S=e=>m(new Uint8Array(A(e)>>3));const b=(e,t)=>{if(t.length<<3!==A(e))throw new u("Invalid Initialization Vector length")},v=(e,t)=>{if(e.length<<3!==t)throw new u("Invalid Content Encryption Key length")};function H(){return"function"==typeof WebSocketPair}function C(){try{return void 0!==process.versions.node}catch(e){return!1}}function P(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function K(e,t){return e.name===t}function _(e){return parseInt(e.name.substr(4),10)}function W(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function k(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!K(e.algorithm,"HMAC"))throw P("HMAC");const r=parseInt(t.substr(2),10);if(_(e.algorithm.hash)!==r)throw P(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!K(e.algorithm,"RSASSA-PKCS1-v1_5"))throw P("RSASSA-PKCS1-v1_5");const r=parseInt(t.substr(2),10);if(_(e.algorithm.hash)!==r)throw P(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!K(e.algorithm,"RSA-PSS"))throw P("RSA-PSS");const r=parseInt(t.substr(2),10);if(_(e.algorithm.hash)!==r)throw P(`SHA-${r}`,"algorithm.hash");break}case C()&&"EdDSA":if("NODE-ED25519"!==e.algorithm.name&&"NODE-ED448"!==e.algorithm.name)throw P("NODE-ED25519 or NODE-ED448");break;case H()&&"EdDSA":if(!K(e.algorithm,"NODE-ED25519"))throw P("NODE-ED25519");break;case"ES256":case"ES384":case"ES512":{if(!K(e.algorithm,"ECDSA"))throw P("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw P(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}W(e,r)}function U(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!K(e.algorithm,"AES-GCM"))throw P("AES-GCM");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw P(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!K(e.algorithm,"AES-KW"))throw P("AES-KW");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw P(r,"algorithm.length");break}case"ECDH-ES":if(!K(e.algorithm,"ECDH"))throw P("ECDH");break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!K(e.algorithm,"PBKDF2"))throw P("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!K(e.algorithm,"RSA-OAEP"))throw P("RSA-OAEP");const r=parseInt(t.substr(9),10)||1;if(_(e.algorithm.hash)!==r)throw P(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}W(e,r)}var R=(e,...t)=>{let r="Key must be ";if(t.length>2){const e=t.pop();r+=`one of type ${t.join(", ")}, or ${e}.`}else 2===t.length?r+=`one of type ${t[0]} or ${t[1]}.`:r+=`of type ${t[0]}.`;return null==e?r+=` Received ${e}`:"function"==typeof e&&e.name?r+=` Received function ${e.name}`:"object"==typeof e&&null!=e&&e.constructor&&e.constructor.name&&(r+=` Received an instance of ${e.constructor.name}`),r},J=e=>E(e);const D=["CryptoKey"];async function O(e,t,n,o,i,s){if(!(t instanceof Uint8Array))throw new TypeError(R(t,"Uint8Array"));const c=parseInt(e.substr(1,3),10),d=await g.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),p=await g.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),h=r(s,o,n,a(s.length<<3)),u=new Uint8Array((await g.subtle.sign("HMAC",p,h)).slice(0,c>>3));let w,l;try{w=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let n=0,a=-1;for(;++a<r;)n|=e[a]^t[a];return 0===n})(i,u)}catch(e){}if(!w)throw new y;try{l=new Uint8Array(await g.subtle.decrypt({iv:o,name:"AES-CBC"},d,n))}catch(e){}if(!l)throw new y;return l}const T=async(e,t,n,a,o,i)=>{if(!(E(t)||t instanceof Uint8Array))throw new TypeError(R(t,...D,"Uint8Array"));switch(b(e,a),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&v(t,parseInt(e.substr(-3),10)),O(e,t,n,a,o,i);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&v(t,parseInt(e.substr(1,3),10)),async function(e,t,n,a,o,i){let s;t instanceof Uint8Array?s=await g.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(U(t,e,"decrypt"),s=t);try{return new Uint8Array(await g.subtle.decrypt({additionalData:i,iv:a,name:"AES-GCM",tagLength:128},s,r(n,o)))}catch(e){throw new y}}(e,t,n,a,o,i);default:throw new h("Unsupported JWE Content Encryption Algorithm")}},M=async()=>{throw new h('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.')},I=async()=>{throw new h('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.')},x=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function B(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const $=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function G(e,t){if(e.algorithm.length!==parseInt(t.substr(1,3),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function j(e,t,r){if(E(e))return U(e,t,r),e;if(e instanceof Uint8Array)return g.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(R(e,...D,"Uint8Array"))}const N=async(e,t,r)=>{const n=await j(t,e,"wrapKey");G(n,e);const a=await g.subtle.importKey("raw",r,...$);return new Uint8Array(await g.subtle.wrapKey("raw",a,n,"AES-KW"))},z=async(e,t,r)=>{const n=await j(t,e,"unwrapKey");G(n,e);const a=await g.subtle.unwrapKey("raw",r,n,"AES-KW",...$);return new Uint8Array(await g.subtle.exportKey("raw",a))},F=async(e,t)=>{const r=`SHA-${e.substr(-3)}`;return new Uint8Array(await g.subtle.digest(r,t))},L=async(t,n,a,s,c=new Uint8Array(0),d=new Uint8Array(0))=>{if(!E(t))throw new TypeError(R(t,...D));if(U(t,"ECDH-ES"),!E(n))throw new TypeError(R(n,...D));U(n,"ECDH-ES","deriveBits","deriveKey");const p=r(i(e.encode(a)),i(c),i(d),o(s));if(!n.usages.includes("deriveBits"))throw new TypeError('ECDH-ES private key "usages" must include "deriveBits"');const h=new Uint8Array(await g.subtle.deriveBits({name:"ECDH",public:t},n,Math.ceil(parseInt(n.algorithm.namedCurve.substr(-3),10)/8)<<3));return async function(e,t,n,a){const i=Math.ceil((n>>3)/32);let s;for(let n=1;n<=i;n++){const i=new Uint8Array(4+t.length+a.length);i.set(o(n)),i.set(t,4),i.set(a,4+t.length),s=s?r(s,await e("sha256",i)):await e("sha256",i)}return s=s.slice(0,n>>3),s}(F,h,s,p)},V=e=>{if(!E(e))throw new TypeError(R(e,...D));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)};async function Y(t,n,a,o){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new u("PBES2 Salt Input must be 8 or more octets")}(t);const i=function(t,n){return r(e.encode(t),new Uint8Array([0]),n)}(n,t),s=parseInt(n.substr(13,3),10),c={hash:`SHA-${n.substr(8,3)}`,iterations:a,name:"PBKDF2",salt:i},d={length:s,name:"AES-KW"},p=await function(e,t){if(e instanceof Uint8Array)return g.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(E(e))return U(e,t,"deriveBits","deriveKey"),e;throw new TypeError(R(e,...D,"Uint8Array"))}(o,n);if(p.usages.includes("deriveBits"))return new Uint8Array(await g.subtle.deriveBits(c,p,s));if(p.usages.includes("deriveKey"))return g.subtle.deriveKey(c,p,d,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}function q(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new h(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var X=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function Q(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new h(`Unsupported JWE Algorithm: ${e}`)}}var Z=e=>m(new Uint8Array(Q(e)>>3));var ee=async e=>{var t,r;const{algorithm:n,keyUsages:a}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.substr(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new h(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.substr(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case(H()||C())&&"OKP":if("EdDSA"!==e.alg)throw new h('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');switch(e.crv){case"Ed25519":t={name:"NODE-ED25519",namedCurve:"NODE-ED25519"},r=e.d?["sign"]:["verify"];break;case C()&&"Ed448":t={name:"NODE-ED448",namedCurve:"NODE-ED448"},r=e.d?["sign"]:["verify"];break;default:throw new h('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value')}break;default:throw new h('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),o=[n,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:a];if("PBKDF2"===n.name)return g.subtle.importKey("raw",c(e.k),...o);const i={...e};return delete i.alg,g.subtle.importKey("jwk",i,...o)};async function te(e,t,r){if(!B(e))throw new TypeError("JWK must be an object");if(t||(t=e.alg),"string"!=typeof t||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?ee({...e,alg:t,ext:!1}):c(e.k);case"RSA":if(void 0!==e.oth)throw new h('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return ee({...e,alg:t});default:throw new h('Unsupported "kty" (Key Type) Parameter value')}}const re=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?(e=>{if(!(e instanceof Uint8Array)){if(!J(e))throw new TypeError(R(e,...D,"Uint8Array"));if("secret"!==e.type)throw new TypeError(`${D.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(t):((e,t)=>{if(!J(e))throw new TypeError(R(e,...D));if("secret"===e.type)throw new TypeError(`${D.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===t&&"public"===e.type)throw new TypeError(`${D.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===t&&"public"===e.type)throw new TypeError(`${D.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(e.algorithm&&"verify"===t&&"private"===e.type)throw new TypeError(`${D.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(e.algorithm&&"encrypt"===t&&"private"===e.type)throw new TypeError(`${D.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(t,r)};const ne=async(e,t,n,o,i)=>{if(!(E(n)||n instanceof Uint8Array))throw new TypeError(R(n,...D,"Uint8Array"));switch(b(e,o),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return n instanceof Uint8Array&&v(n,parseInt(e.substr(-3),10)),async function(e,t,n,o,i){if(!(n instanceof Uint8Array))throw new TypeError(R(n,"Uint8Array"));const s=parseInt(e.substr(1,3),10),c=await g.subtle.importKey("raw",n.subarray(s>>3),"AES-CBC",!1,["encrypt"]),d=await g.subtle.importKey("raw",n.subarray(0,s>>3),{hash:"SHA-"+(s<<1),name:"HMAC"},!1,["sign"]),p=new Uint8Array(await g.subtle.encrypt({iv:o,name:"AES-CBC"},c,t)),h=r(i,o,p,a(i.length<<3));return{ciphertext:p,tag:new Uint8Array((await g.subtle.sign("HMAC",d,h)).slice(0,s>>3))}}(e,t,n,o,i);case"A128GCM":case"A192GCM":case"A256GCM":return n instanceof Uint8Array&&v(n,parseInt(e.substr(1,3),10)),async function(e,t,r,n,a){let o;r instanceof Uint8Array?o=await g.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(U(r,e,"encrypt"),o=r);const i=new Uint8Array(await g.subtle.encrypt({additionalData:a,iv:n,name:"AES-GCM",tagLength:128},o,t)),s=i.slice(-16);return{ciphertext:i.slice(0,-16),tag:s}}(e,t,n,o,i);default:throw new h("Unsupported JWE Content Encryption Algorithm")}};async function ae(e,t,r,n){switch(re(e,t,"decrypt"),e){case"dir":if(void 0!==r)throw new u("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new u("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!B(n.epk))throw new u('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!V(t))throw new h("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const a=await te(n.epk,e);let o,i;if(void 0!==n.apu){if("string"!=typeof n.apu)throw new u('JOSE Header "apu" (Agreement PartyUInfo) invalid');o=c(n.apu)}if(void 0!==n.apv){if("string"!=typeof n.apv)throw new u('JOSE Header "apv" (Agreement PartyVInfo) invalid');i=c(n.apv)}const s=await L(a,t,"ECDH-ES"===e?n.enc:e,"ECDH-ES"===e?Q(n.enc):parseInt(e.substr(-5,3),10),o,i);if("ECDH-ES"===e)return s;if(void 0===r)throw new u("JWE Encrypted Key missing");return z(e.substr(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new u("JWE Encrypted Key missing");return(async(e,t,r)=>{if(!E(t))throw new TypeError(R(t,...D));if(U(t,e,"decrypt","unwrapKey"),X(e,t),t.usages.includes("decrypt"))return new Uint8Array(await g.subtle.decrypt(q(e),t,r));if(t.usages.includes("unwrapKey")){const n=await g.subtle.unwrapKey("raw",r,t,q(e),...$);return new Uint8Array(await g.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(void 0===r)throw new u("JWE Encrypted Key missing");if("number"!=typeof n.p2c)throw new u('JOSE Header "p2c" (PBES2 Count) missing or invalid');if("string"!=typeof n.p2s)throw new u('JOSE Header "p2s" (PBES2 Salt) missing or invalid');return(async(e,t,r,n,a)=>{const o=await Y(a,e,n,t);return z(e.substr(-6),o,r)})(e,t,r,n.p2c,c(n.p2s));case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new u("JWE Encrypted Key missing");return z(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":if(void 0===r)throw new u("JWE Encrypted Key missing");if("string"!=typeof n.iv)throw new u('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof n.tag)throw new u('JOSE Header "tag" (Authentication Tag) missing or invalid');return async function(e,t,r,n,a){const o=e.substr(0,7);return T(o,t,r,n,a,new Uint8Array(0))}(e,t,r,c(n.iv),c(n.tag));default:throw new h('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function oe(e,t,r,n,a){if(void 0!==a.crit&&void 0===n.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;o=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of n.crit){if(!o.has(t))throw new h(`Extension Header Parameter "${t}" is not recognized`);if(void 0===a[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(o.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)}const ie=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function se(n,a,o){var i;if(!B(n))throw new u("Flattened JWE must be an object");if(void 0===n.protected&&void 0===n.header&&void 0===n.unprotected)throw new u("JOSE Header missing");if("string"!=typeof n.iv)throw new u("JWE Initialization Vector missing or incorrect type");if("string"!=typeof n.ciphertext)throw new u("JWE Ciphertext missing or incorrect type");if("string"!=typeof n.tag)throw new u("JWE Authentication Tag missing or incorrect type");if(void 0!==n.protected&&"string"!=typeof n.protected)throw new u("JWE Protected Header incorrect type");if(void 0!==n.encrypted_key&&"string"!=typeof n.encrypted_key)throw new u("JWE Encrypted Key incorrect type");if(void 0!==n.aad&&"string"!=typeof n.aad)throw new u("JWE AAD incorrect type");if(void 0!==n.header&&!B(n.header))throw new u("JWE Shared Unprotected Header incorrect type");if(void 0!==n.unprotected&&!B(n.unprotected))throw new u("JWE Per-Recipient Unprotected Header incorrect type");let s;if(n.protected){const e=c(n.protected);try{s=JSON.parse(t.decode(e))}catch(e){throw new u("JWE Protected Header is invalid")}}if(!x(s,n.header,n.unprotected))throw new u("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const d={...s,...n.header,...n.unprotected};if(oe(u,new Map,null==o?void 0:o.crit,s,d),void 0!==d.zip){if(!s||!s.zip)throw new u('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==d.zip)throw new h('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:y,enc:w}=d;if("string"!=typeof y||!y)throw new u("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof w||!w)throw new u("missing JWE Encryption Algorithm (enc) in JWE Header");const l=o&&ie("keyManagementAlgorithms",o.keyManagementAlgorithms),f=o&&ie("contentEncryptionAlgorithms",o.contentEncryptionAlgorithms);if(l&&!l.has(y))throw new p('"alg" (Algorithm) Header Parameter not allowed');if(f&&!f.has(w))throw new p('"enc" (Encryption Algorithm) Header Parameter not allowed');let g;void 0!==n.encrypted_key&&(g=c(n.encrypted_key));let E,m=!1;"function"==typeof a&&(a=await a(s,n),m=!0);try{E=await ae(y,a,g,d)}catch(e){if(e instanceof TypeError)throw e;E=Z(w)}const A=c(n.iv),S=c(n.tag),b=e.encode(null!==(i=n.protected)&&void 0!==i?i:"");let v;v=void 0!==n.aad?r(b,e.encode("."),e.encode(n.aad)):b;let H=await T(w,E,c(n.ciphertext),A,S,v);"DEF"===d.zip&&(H=await((null==o?void 0:o.inflateRaw)||M)(H));const C={plaintext:H};return void 0!==n.protected&&(C.protectedHeader=s),void 0!==n.aad&&(C.additionalAuthenticatedData=c(n.aad)),void 0!==n.unprotected&&(C.sharedUnprotectedHeader=n.unprotected),void 0!==n.header&&(C.unprotectedHeader=n.header),m?{...C,key:a}:C}async function ce(e,r,n){if(e instanceof Uint8Array&&(e=t.decode(e)),"string"!=typeof e)throw new u("Compact JWE must be a string or Uint8Array");const{0:a,1:o,2:i,3:s,4:c,length:d}=e.split(".");if(5!==d)throw new u("Invalid Compact JWE");const p=await se({ciphertext:s||void 0,iv:i||void 0,protected:a||void 0,tag:c||void 0,encrypted_key:o||void 0},r,n),h={plaintext:p.plaintext,protectedHeader:p.protectedHeader};return"function"==typeof r?{...h,key:p.key}:h}var de=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:s(e)};if(!E(e))throw new TypeError(R(e,...D,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:r,alg:n,use:a,...o}=await g.subtle.exportKey("jwk",e);return o};async function pe(e){return de(e)}async function he(e,t,r,n,a={}){let o,i,c;switch(re(e,r,"encrypt"),e){case"dir":c=r;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!V(r))throw new h("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const{apu:d,apv:p}=a;let{epk:y}=a;y||(y=await(async e=>{if(!E(e))throw new TypeError(R(e,...D));return(await g.subtle.generateKey({name:"ECDH",namedCurve:e.algorithm.namedCurve},!0,["deriveBits"])).privateKey})(r));const{x:u,y:w,crv:l,kty:f}=await pe(y),m=await L(r,y,"ECDH-ES"===e?t:e,"ECDH-ES"===e?Q(t):parseInt(e.substr(-5,3),10),d,p);if(i={epk:{x:u,y:w,crv:l,kty:f}},d&&(i.apu=s(d)),p&&(i.apv=s(p)),"ECDH-ES"===e){c=m;break}c=n||Z(t);const A=e.substr(-6);o=await N(A,m,c);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":c=n||Z(t),o=await(async(e,t,r)=>{if(!E(t))throw new TypeError(R(t,...D));if(U(t,e,"encrypt","wrapKey"),X(e,t),t.usages.includes("encrypt"))return new Uint8Array(await g.subtle.encrypt(q(e),t,r));if(t.usages.includes("wrapKey")){const n=await g.subtle.importKey("raw",r,...$);return new Uint8Array(await g.subtle.wrapKey("raw",n,t,q(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,r,c);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{c=n||Z(t);const{p2c:d,p2s:p}=a;({encryptedKey:o,...i}=await(async(e,t,r,n=Math.floor(2049*Math.random())+2048,a=m(new Uint8Array(16)))=>{const o=await Y(a,e,n,t);return{encryptedKey:await N(e.substr(-6),o,r),p2c:n,p2s:s(a)}})(e,r,c,d,p));break}case"A128KW":case"A192KW":case"A256KW":c=n||Z(t),o=await N(e,r,c);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{c=n||Z(t);const{iv:d}=a;({encryptedKey:o,...i}=await async function(e,t,r,n){const a=e.substr(0,7);n||(n=S(a));const{ciphertext:o,tag:i}=await ne(a,r,t,n,new Uint8Array(0));return{encryptedKey:o,iv:s(n),tag:s(i)}}(e,r,c,d));break}default:throw new h('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:c,encryptedKey:o,parameters:i}}const ye=Symbol();class ue{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(n,a){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new u("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!x(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new u("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const o={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(oe(u,new Map,null==a?void 0:a.crit,this._protectedHeader,o),void 0!==o.zip){if(!this._protectedHeader||!this._protectedHeader.zip)throw new u('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==o.zip)throw new h('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:i,enc:c}=o;if("string"!=typeof i||!i)throw new u('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof c||!c)throw new u('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let d,p,y,w,l,f,g;if("dir"===i){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if("ECDH-ES"===i&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");{let e;({cek:p,encryptedKey:d,parameters:e}=await he(i,c,n,this._cek,this._keyManagementParameters)),e&&(a&&ye in a?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...e}:this.setUnprotectedHeader(e):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...e}:this.setProtectedHeader(e))}if(this._iv||(this._iv=S(c)),w=this._protectedHeader?e.encode(s(JSON.stringify(this._protectedHeader))):e.encode(""),this._aad?(l=s(this._aad),y=r(w,e.encode("."),e.encode(l))):y=w,"DEF"===o.zip){const e=await((null==a?void 0:a.deflateRaw)||I)(this._plaintext);({ciphertext:f,tag:g}=await ne(c,e,p,this._iv,y))}else({ciphertext:f,tag:g}=await ne(c,this._plaintext,p,this._iv,y));const E={ciphertext:s(f),iv:s(this._iv),tag:s(g)};return d&&(E.encrypted_key=s(d)),l&&(E.aad=l),this._protectedHeader&&(E.protected=t.decode(w)),this._sharedUnprotectedHeader&&(E.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(E.header=this._unprotectedHeader),E}}function we(e,t){const r=parseInt(e.substr(-3),10);switch(e){case"HS256":case"HS384":case"HS512":return{hash:`SHA-${r}`,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:`SHA-${r}`,name:"RSA-PSS",saltLength:r>>3};case"RS256":case"RS384":case"RS512":return{hash:`SHA-${r}`,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:`SHA-${r}`,name:"ECDSA",namedCurve:t};case(H()||C())&&"EdDSA":return{name:t,namedCurve:t};default:throw new h(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function le(e,t,r){if(E(t))return k(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(R(t,...D));return g.subtle.importKey("raw",t,{hash:`SHA-${e.substr(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(R(t,...D,"Uint8Array"))}async function fe(n,a,o){var i;if(!B(n))throw new w("Flattened JWS must be an object");if(void 0===n.protected&&void 0===n.header)throw new w('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==n.protected&&"string"!=typeof n.protected)throw new w("JWS Protected Header incorrect type");if(void 0===n.payload)throw new w("JWS Payload missing");if("string"!=typeof n.signature)throw new w("JWS Signature missing or incorrect type");if(void 0!==n.header&&!B(n.header))throw new w("JWS Unprotected Header incorrect type");let s={};if(n.protected){const e=c(n.protected);try{s=JSON.parse(t.decode(e))}catch(e){throw new w("JWS Protected Header is invalid")}}if(!x(s,n.header))throw new w("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const d={...s,...n.header};let h=!0;if(oe(w,new Map([["b64",!0]]),null==o?void 0:o.crit,s,d).has("b64")&&(h=s.b64,"boolean"!=typeof h))throw new w('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:y}=d;if("string"!=typeof y||!y)throw new w('JWS "alg" (Algorithm) Header Parameter missing or invalid');const u=o&&ie("algorithms",o.algorithms);if(u&&!u.has(y))throw new p('"alg" (Algorithm) Header Parameter not allowed');if(h){if("string"!=typeof n.payload)throw new w("JWS Payload must be a string")}else if("string"!=typeof n.payload&&!(n.payload instanceof Uint8Array))throw new w("JWS Payload must be a string or an Uint8Array instance");let l=!1;"function"==typeof a&&(a=await a(s,n),l=!0),re(y,a,"verify");const E=r(e.encode(null!==(i=n.protected)&&void 0!==i?i:""),e.encode("."),"string"==typeof n.payload?e.encode(n.payload):n.payload),m=c(n.signature),A=await(async(e,t,r,n)=>{const a=await le(e,t,"verify");X(e,a);const o=we(e,a.algorithm.namedCurve);try{return await g.subtle.verify(o,a,r,n)}catch(e){return!1}})(y,a,m,E);if(!A)throw new f;let S;S=h?c(n.payload):"string"==typeof n.payload?e.encode(n.payload):n.payload;const b={payload:S};return void 0!==n.protected&&(b.protectedHeader=s),void 0!==n.header&&(b.unprotectedHeader=n.header),l?{...b,key:a}:b}async function ge(e,r,n){if(e instanceof Uint8Array&&(e=t.decode(e)),"string"!=typeof e)throw new w("Compact JWS must be a string or Uint8Array");const{0:a,1:o,2:i,length:s}=e.split(".");if(3!==s)throw new w("Invalid Compact JWS");const c=await fe({payload:o,protected:a,signature:i},r,n),d={payload:c.payload,protectedHeader:c.protectedHeader};return"function"==typeof r?{...d,key:c.key}:d}class Ee{constructor(e){this._flattened=new ue(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}class me{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(n,a){if(!this._protectedHeader&&!this._unprotectedHeader)throw new w("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!x(this._protectedHeader,this._unprotectedHeader))throw new w("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const o={...this._protectedHeader,...this._unprotectedHeader};let i=!0;if(oe(w,new Map([["b64",!0]]),null==a?void 0:a.crit,this._protectedHeader,o).has("b64")&&(i=this._protectedHeader.b64,"boolean"!=typeof i))throw new w('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=o;if("string"!=typeof c||!c)throw new w('JWS "alg" (Algorithm) Header Parameter missing or invalid');re(c,n,"sign");let d,p=this._payload;i&&(p=e.encode(s(p))),d=this._protectedHeader?e.encode(s(JSON.stringify(this._protectedHeader))):e.encode("");const h=r(d,e.encode("."),p),y=await(async(e,t,r)=>{const n=await le(e,t,"sign");X(e,n);const a=await g.subtle.sign(we(e,n.algorithm.namedCurve),n,r);return new Uint8Array(a)})(c,n,h),u={signature:s(y),payload:""};return i&&(u.payload=t.decode(p)),this._unprotectedHeader&&(u.header=this._unprotectedHeader),this._protectedHeader&&(u.protected=t.decode(d)),u}}class Ae{constructor(e){this._flattened=new me(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}const Se=(e,t)=>{if("string"!=typeof e||!e)throw new l(`${t} missing or invalid`)};const be=async function(e,t="SHA-256"){const r=["SHA-1","SHA-256","SHA-384","SHA-512"];if(!r.includes(t))throw new RangeError(`Valid hash algorith values are any of ${JSON.stringify(r)}`);const n=new TextEncoder,a="string"==typeof e?n.encode(e).buffer:e;let o="";{const e=await crypto.subtle.digest(t,a),r="0123456789abcdef";new Uint8Array(e).forEach((e=>{o+=r[e>>4]+r[15&e]}))}return o},ve=async(e,t,r)=>{const n=await He(e,t);if(await be(r)!==n.exchange.poo_dgst)throw new Error("the hashed proof of origin received does not correspond to the poo_dgst parameter in the proof of origin");if(Date.now()-n.iat>5e3)throw new Error("timestamp error");return!0},He=async(e,t)=>{const{payload:r}=await ge(t,e).catch((e=>{throw new Error(`PoR: ${String(e)}`)}));return JSON.parse((new TextDecoder).decode(r).toString())},Ce=async(e,t,r)=>{const n=await Pe(e,t),a=await be(r);if(n.exchange.cipherblock_dgst!==a)throw new Error("the cipherblock_dgst parameter in the proof of origin does not correspond to hash of the cipherblock received by the provider");if(Date.now()-n.iat>5e3)throw new Error("timestamp error");return!0},Pe=async(e,t)=>{const{payload:r}=await ge(t,e).catch((e=>{throw new Error("PoO "+String(e))}));return JSON.parse((new TextDecoder).decode(r).toString())},Ke=(e,t,r,n,a)=>new Promise(((o,i)=>{ge(r,e).catch((e=>{i(new Error("PoP "+String(e)))})),Pe(t,a).then((e=>{be(JSON.stringify(n)).then((t=>{e.exchange.key_commitment===t?o(!0):i(new Error("hashed key not correspond to poO key_commitment parameter"))})).catch((e=>i(e)))})).catch((e=>i(e)))})),_e=async(e,t)=>{const r=new TextDecoder,n=await te(t,"A256GCM"),{plaintext:a}=await ce(e,n);return r.decode(a)},We=async(e,t,r,n)=>{const a=await _e(t,r);if(await be(a)===n.exchange.block_commitment)return!0;throw new Error("hashed CipherBlock not correspond to block_commitment parameter included in the proof of origin")},ke="ES256",Ue=async(e,t,r,n,a,o,i)=>{const s="string"==typeof t?(new TextEncoder).encode(t):new Uint8Array(t),c=await te(i),d=await new Ee(s).setProtectedHeader({alg:"dir",enc:"A256GCM"}).encrypt(c),p=await be(d),h=await be(s),y=await be(JSON.stringify(i)),u={iss:r,sub:n,iat:Date.now(),exchange:{id:a,orig:r,dest:n,block_id:o,block_desc:"description",hash_alg:"sha256",cipherblock_dgst:p,block_commitment:h,key_commitment:y}};return{cipherblock:d,poO:await Je(e,u)}},Re=async()=>{let t;t=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);const r=await pe(t),n=await async function(t,r="sha256"){if(!B(t))throw new TypeError("JWK must be an object");let n;switch(t.kty){case"EC":Se(t.crv,'"crv" (Curve) Parameter'),Se(t.x,'"x" (X Coordinate) Parameter'),Se(t.y,'"y" (Y Coordinate) Parameter'),n={crv:t.crv,kty:t.kty,x:t.x,y:t.y};break;case"OKP":Se(t.crv,'"crv" (Subtype of Key Pair) Parameter'),Se(t.x,'"x" (Public Key) Parameter'),n={crv:t.crv,kty:t.kty,x:t.x};break;case"RSA":Se(t.e,'"e" (Exponent) Parameter'),Se(t.n,'"n" (Modulus) Parameter'),n={e:t.e,kty:t.kty,n:t.n};break;case"oct":Se(t.k,'"k" (Key Value) Parameter'),n={k:t.k,kty:t.kty};break;default:throw new h('"kty" (Key Type) Parameter missing or unsupported')}const a=e.encode(JSON.stringify(n));return s(await F(r,a))}(r);return r.kid=n,r.alg="A256GCM",r},Je=async(e,t)=>{const r=(new TextEncoder).encode(JSON.stringify(t));return await new Ae(r).setProtectedHeader({alg:"ES256"}).sign(e)},De=async(e,t,r,n,a)=>{const o=await be(t),i={iss:r,sub:n,iat:Date.now(),exchange:{poo_dgst:o,hash_alg:"sha256",exchangeId:a}};return await Je(e,i)},Oe=async(e,t,r,n)=>{const a=await Pe(e,t);return{privateStorage:{availability:"privateStorage",permissions:{view:[a.exchange.orig,a.exchange.dest]},type:"dict",id:a.exchange.id,content:{[a.exchange.block_id]:{poO:t,poR:r}}},blockchain:{availability:"blockchain",type:"jwk",content:{[n.kid]:n}}}};export{ke as SIGNING_ALG,Oe as createBlockchainProof,Re as createJwk,Ue as createPoO,De as createPoR,Pe as decodePoo,He as decodePor,_e as decryptCipherblock,be as sha,Je as signProof,We as validateCipherblock,Ce as validatePoO,Ke as validatePoP,ve as validatePoR};
