!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).nonRepudiationProofs={})}(this,(function(e){"use strict";const t=new TextEncoder,r=new TextDecoder,n=2**32;function a(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let n=0;return e.forEach((e=>{r.set(e,n),n+=e.length})),r}function o(e,t,r){if(t<0||t>=n)throw new RangeError(`value must be >= 0 and <= 4294967295. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function i(e){const t=Math.floor(e/n),r=e%n,a=new Uint8Array(8);return o(a,t,0),o(a,r,4),a}function s(e){const t=new Uint8Array(4);return o(t,e),t}function c(e){return a(s(e.length),e)}const d=e=>(e=>{let r=e;"string"==typeof r&&(r=t.encode(r));const n=[];for(let e=0;e<r.length;e+=32768)n.push(String.fromCharCode.apply(null,r.subarray(e,e+32768)));return btoa(n.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),p=e=>{let t=e;t instanceof Uint8Array&&(t=r.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>new Uint8Array(atob(e).split("").map((e=>e.charCodeAt(0)))))(t)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class h extends Error{constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}static get code(){return"ERR_JOSE_GENERIC"}}class y extends h{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class u extends h{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class w extends h{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class l extends h{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class f extends h{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class g extends h{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}static get code(){return"ERR_JWK_INVALID"}}class E extends h{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var m=crypto;function A(e){try{return null!=e&&"boolean"==typeof e.extractable&&"string"==typeof e.algorithm.name&&"string"==typeof e.type}catch(e){return!1}}var S=m.getRandomValues.bind(m);function b(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new u(`Unsupported JWE Algorithm: ${e}`)}}var v=e=>S(new Uint8Array(b(e)>>3));const H=(e,t)=>{if(t.length<<3!==b(e))throw new l("Invalid Initialization Vector length")},C=(e,t)=>{if(e.length<<3!==t)throw new l("Invalid Content Encryption Key length")};function P(){return"function"==typeof WebSocketPair}function K(){try{return void 0!==process.versions.node}catch(e){return!1}}function _(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function W(e,t){return e.name===t}function k(e){return parseInt(e.name.substr(4),10)}function U(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function R(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!W(e.algorithm,"HMAC"))throw _("HMAC");const r=parseInt(t.substr(2),10);if(k(e.algorithm.hash)!==r)throw _(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!W(e.algorithm,"RSASSA-PKCS1-v1_5"))throw _("RSASSA-PKCS1-v1_5");const r=parseInt(t.substr(2),10);if(k(e.algorithm.hash)!==r)throw _(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!W(e.algorithm,"RSA-PSS"))throw _("RSA-PSS");const r=parseInt(t.substr(2),10);if(k(e.algorithm.hash)!==r)throw _(`SHA-${r}`,"algorithm.hash");break}case K()&&"EdDSA":if("NODE-ED25519"!==e.algorithm.name&&"NODE-ED448"!==e.algorithm.name)throw _("NODE-ED25519 or NODE-ED448");break;case P()&&"EdDSA":if(!W(e.algorithm,"NODE-ED25519"))throw _("NODE-ED25519");break;case"ES256":case"ES384":case"ES512":{if(!W(e.algorithm,"ECDSA"))throw _("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw _(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}U(e,r)}function J(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!W(e.algorithm,"AES-GCM"))throw _("AES-GCM");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw _(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!W(e.algorithm,"AES-KW"))throw _("AES-KW");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw _(r,"algorithm.length");break}case"ECDH-ES":if(!W(e.algorithm,"ECDH"))throw _("ECDH");break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!W(e.algorithm,"PBKDF2"))throw _("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!W(e.algorithm,"RSA-OAEP"))throw _("RSA-OAEP");const r=parseInt(t.substr(9),10)||1;if(k(e.algorithm.hash)!==r)throw _(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}U(e,r)}var D=(e,...t)=>{let r="Key must be ";if(t.length>2){const e=t.pop();r+=`one of type ${t.join(", ")}, or ${e}.`}else 2===t.length?r+=`one of type ${t[0]} or ${t[1]}.`:r+=`of type ${t[0]}.`;return null==e?r+=` Received ${e}`:"function"==typeof e&&e.name?r+=` Received function ${e.name}`:"object"==typeof e&&null!=e&&e.constructor&&e.constructor.name&&(r+=` Received an instance of ${e.constructor.name}`),r},O=e=>A(e);const T=["CryptoKey"];async function M(e,t,r,n,o,s){if(!(t instanceof Uint8Array))throw new TypeError(D(t,"Uint8Array"));const c=parseInt(e.substr(1,3),10),d=await m.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),p=await m.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),h=a(s,n,r,i(s.length<<3)),y=new Uint8Array((await m.subtle.sign("HMAC",p,h)).slice(0,c>>3));let u,l;try{u=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let n=0,a=-1;for(;++a<r;)n|=e[a]^t[a];return 0===n})(o,y)}catch(e){}if(!u)throw new w;try{l=new Uint8Array(await m.subtle.decrypt({iv:n,name:"AES-CBC"},d,r))}catch(e){}if(!l)throw new w;return l}const I=async(e,t,r,n,o,i)=>{if(!(A(t)||t instanceof Uint8Array))throw new TypeError(D(t,...T,"Uint8Array"));switch(H(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&C(t,parseInt(e.substr(-3),10)),M(e,t,r,n,o,i);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&C(t,parseInt(e.substr(1,3),10)),async function(e,t,r,n,o,i){let s;t instanceof Uint8Array?s=await m.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(J(t,e,"decrypt"),s=t);try{return new Uint8Array(await m.subtle.decrypt({additionalData:i,iv:n,name:"AES-GCM",tagLength:128},s,a(r,o)))}catch(e){throw new w}}(e,t,r,n,o,i);default:throw new u("Unsupported JWE Content Encryption Algorithm")}},x=async()=>{throw new u('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.')},B=async()=>{throw new u('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.')},$=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function G(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const j=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function N(e,t){if(e.algorithm.length!==parseInt(t.substr(1,3),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function z(e,t,r){if(A(e))return J(e,t,r),e;if(e instanceof Uint8Array)return m.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(D(e,...T,"Uint8Array"))}const L=async(e,t,r)=>{const n=await z(t,e,"wrapKey");N(n,e);const a=await m.subtle.importKey("raw",r,...j);return new Uint8Array(await m.subtle.wrapKey("raw",a,n,"AES-KW"))},F=async(e,t,r)=>{const n=await z(t,e,"unwrapKey");N(n,e);const a=await m.subtle.unwrapKey("raw",r,n,"AES-KW",...j);return new Uint8Array(await m.subtle.exportKey("raw",a))},V=async(e,t)=>{const r=`SHA-${e.substr(-3)}`;return new Uint8Array(await m.subtle.digest(r,t))},Y=async(e,r,n,o,i=new Uint8Array(0),d=new Uint8Array(0))=>{if(!A(e))throw new TypeError(D(e,...T));if(J(e,"ECDH-ES"),!A(r))throw new TypeError(D(r,...T));J(r,"ECDH-ES","deriveBits","deriveKey");const p=a(c(t.encode(n)),c(i),c(d),s(o));if(!r.usages.includes("deriveBits"))throw new TypeError('ECDH-ES private key "usages" must include "deriveBits"');const h=new Uint8Array(await m.subtle.deriveBits({name:"ECDH",public:e},r,Math.ceil(parseInt(r.algorithm.namedCurve.substr(-3),10)/8)<<3));return async function(e,t,r,n){const o=Math.ceil((r>>3)/32);let i;for(let r=1;r<=o;r++){const o=new Uint8Array(4+t.length+n.length);o.set(s(r)),o.set(t,4),o.set(n,4+t.length),i=i?a(i,await e("sha256",o)):await e("sha256",o)}return i=i.slice(0,r>>3),i}(V,h,o,p)},q=e=>{if(!A(e))throw new TypeError(D(e,...T));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)};async function X(e,r,n,o){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new l("PBES2 Salt Input must be 8 or more octets")}(e);const i=function(e,r){return a(t.encode(e),new Uint8Array([0]),r)}(r,e),s=parseInt(r.substr(13,3),10),c={hash:`SHA-${r.substr(8,3)}`,iterations:n,name:"PBKDF2",salt:i},d={length:s,name:"AES-KW"},p=await function(e,t){if(e instanceof Uint8Array)return m.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(A(e))return J(e,t,"deriveBits","deriveKey"),e;throw new TypeError(D(e,...T,"Uint8Array"))}(o,r);if(p.usages.includes("deriveBits"))return new Uint8Array(await m.subtle.deriveBits(c,p,s));if(p.usages.includes("deriveKey"))return m.subtle.deriveKey(c,p,d,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}function Q(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new u(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var Z=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function ee(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new u(`Unsupported JWE Algorithm: ${e}`)}}var te=e=>S(new Uint8Array(ee(e)>>3));var re=async e=>{var t,r;const{algorithm:n,keyUsages:a}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.substr(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new u(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new u('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.substr(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new u('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new u('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case(P()||K())&&"OKP":if("EdDSA"!==e.alg)throw new u('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');switch(e.crv){case"Ed25519":t={name:"NODE-ED25519",namedCurve:"NODE-ED25519"},r=e.d?["sign"]:["verify"];break;case K()&&"Ed448":t={name:"NODE-ED448",namedCurve:"NODE-ED448"},r=e.d?["sign"]:["verify"];break;default:throw new u('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value')}break;default:throw new u('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),o=[n,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:a];if("PBKDF2"===n.name)return m.subtle.importKey("raw",p(e.k),...o);const i={...e};return delete i.alg,m.subtle.importKey("jwk",i,...o)};async function ne(e,t,r){if(!G(e))throw new TypeError("JWK must be an object");if(t||(t=e.alg),"string"!=typeof t||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?re({...e,alg:t,ext:!1}):p(e.k);case"RSA":if(void 0!==e.oth)throw new u('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return re({...e,alg:t});default:throw new u('Unsupported "kty" (Key Type) Parameter value')}}const ae=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?(e=>{if(!(e instanceof Uint8Array)){if(!O(e))throw new TypeError(D(e,...T,"Uint8Array"));if("secret"!==e.type)throw new TypeError(`${T.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(t):((e,t)=>{if(!O(e))throw new TypeError(D(e,...T));if("secret"===e.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===t&&"public"===e.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===t&&"public"===e.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(e.algorithm&&"verify"===t&&"private"===e.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(e.algorithm&&"encrypt"===t&&"private"===e.type)throw new TypeError(`${T.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(t,r)};const oe=async(e,t,r,n,o)=>{if(!(A(r)||r instanceof Uint8Array))throw new TypeError(D(r,...T,"Uint8Array"));switch(H(e,n),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r instanceof Uint8Array&&C(r,parseInt(e.substr(-3),10)),async function(e,t,r,n,o){if(!(r instanceof Uint8Array))throw new TypeError(D(r,"Uint8Array"));const s=parseInt(e.substr(1,3),10),c=await m.subtle.importKey("raw",r.subarray(s>>3),"AES-CBC",!1,["encrypt"]),d=await m.subtle.importKey("raw",r.subarray(0,s>>3),{hash:"SHA-"+(s<<1),name:"HMAC"},!1,["sign"]),p=new Uint8Array(await m.subtle.encrypt({iv:n,name:"AES-CBC"},c,t)),h=a(o,n,p,i(o.length<<3));return{ciphertext:p,tag:new Uint8Array((await m.subtle.sign("HMAC",d,h)).slice(0,s>>3))}}(e,t,r,n,o);case"A128GCM":case"A192GCM":case"A256GCM":return r instanceof Uint8Array&&C(r,parseInt(e.substr(1,3),10)),async function(e,t,r,n,a){let o;r instanceof Uint8Array?o=await m.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(J(r,e,"encrypt"),o=r);const i=new Uint8Array(await m.subtle.encrypt({additionalData:a,iv:n,name:"AES-GCM",tagLength:128},o,t)),s=i.slice(-16);return{ciphertext:i.slice(0,-16),tag:s}}(e,t,r,n,o);default:throw new u("Unsupported JWE Content Encryption Algorithm")}};async function ie(e,t,r,n){switch(ae(e,t,"decrypt"),e){case"dir":if(void 0!==r)throw new l("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new l("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!G(n.epk))throw new l('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!q(t))throw new u("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const a=await ne(n.epk,e);let o,i;if(void 0!==n.apu){if("string"!=typeof n.apu)throw new l('JOSE Header "apu" (Agreement PartyUInfo) invalid');o=p(n.apu)}if(void 0!==n.apv){if("string"!=typeof n.apv)throw new l('JOSE Header "apv" (Agreement PartyVInfo) invalid');i=p(n.apv)}const s=await Y(a,t,"ECDH-ES"===e?n.enc:e,"ECDH-ES"===e?ee(n.enc):parseInt(e.substr(-5,3),10),o,i);if("ECDH-ES"===e)return s;if(void 0===r)throw new l("JWE Encrypted Key missing");return F(e.substr(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new l("JWE Encrypted Key missing");return(async(e,t,r)=>{if(!A(t))throw new TypeError(D(t,...T));if(J(t,e,"decrypt","unwrapKey"),Z(e,t),t.usages.includes("decrypt"))return new Uint8Array(await m.subtle.decrypt(Q(e),t,r));if(t.usages.includes("unwrapKey")){const n=await m.subtle.unwrapKey("raw",r,t,Q(e),...j);return new Uint8Array(await m.subtle.exportKey("raw",n))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(void 0===r)throw new l("JWE Encrypted Key missing");if("number"!=typeof n.p2c)throw new l('JOSE Header "p2c" (PBES2 Count) missing or invalid');if("string"!=typeof n.p2s)throw new l('JOSE Header "p2s" (PBES2 Salt) missing or invalid');return(async(e,t,r,n,a)=>{const o=await X(a,e,n,t);return F(e.substr(-6),o,r)})(e,t,r,n.p2c,p(n.p2s));case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new l("JWE Encrypted Key missing");return F(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":if(void 0===r)throw new l("JWE Encrypted Key missing");if("string"!=typeof n.iv)throw new l('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof n.tag)throw new l('JOSE Header "tag" (Authentication Tag) missing or invalid');return async function(e,t,r,n,a){const o=e.substr(0,7);return I(o,t,r,n,a,new Uint8Array(0))}(e,t,r,p(n.iv),p(n.tag));default:throw new u('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function se(e,t,r,n,a){if(void 0!==a.crit&&void 0===n.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;o=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of n.crit){if(!o.has(t))throw new u(`Extension Header Parameter "${t}" is not recognized`);if(void 0===a[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(o.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)}const ce=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function de(e,n,o){var i;if(!G(e))throw new l("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new l("JOSE Header missing");if("string"!=typeof e.iv)throw new l("JWE Initialization Vector missing or incorrect type");if("string"!=typeof e.ciphertext)throw new l("JWE Ciphertext missing or incorrect type");if("string"!=typeof e.tag)throw new l("JWE Authentication Tag missing or incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new l("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new l("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new l("JWE AAD incorrect type");if(void 0!==e.header&&!G(e.header))throw new l("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!G(e.unprotected))throw new l("JWE Per-Recipient Unprotected Header incorrect type");let s;if(e.protected){const t=p(e.protected);try{s=JSON.parse(r.decode(t))}catch(e){throw new l("JWE Protected Header is invalid")}}if(!$(s,e.header,e.unprotected))throw new l("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const c={...s,...e.header,...e.unprotected};if(se(l,new Map,null==o?void 0:o.crit,s,c),void 0!==c.zip){if(!s||!s.zip)throw new l('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==c.zip)throw new u('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:d,enc:h}=c;if("string"!=typeof d||!d)throw new l("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof h||!h)throw new l("missing JWE Encryption Algorithm (enc) in JWE Header");const w=o&&ce("keyManagementAlgorithms",o.keyManagementAlgorithms),f=o&&ce("contentEncryptionAlgorithms",o.contentEncryptionAlgorithms);if(w&&!w.has(d))throw new y('"alg" (Algorithm) Header Parameter not allowed');if(f&&!f.has(h))throw new y('"enc" (Encryption Algorithm) Header Parameter not allowed');let g;void 0!==e.encrypted_key&&(g=p(e.encrypted_key));let E,m=!1;"function"==typeof n&&(n=await n(s,e),m=!0);try{E=await ie(d,n,g,c)}catch(e){if(e instanceof TypeError)throw e;E=te(h)}const A=p(e.iv),S=p(e.tag),b=t.encode(null!==(i=e.protected)&&void 0!==i?i:"");let v;v=void 0!==e.aad?a(b,t.encode("."),t.encode(e.aad)):b;let H=await I(h,E,p(e.ciphertext),A,S,v);"DEF"===c.zip&&(H=await((null==o?void 0:o.inflateRaw)||x)(H));const C={plaintext:H};return void 0!==e.protected&&(C.protectedHeader=s),void 0!==e.aad&&(C.additionalAuthenticatedData=p(e.aad)),void 0!==e.unprotected&&(C.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(C.unprotectedHeader=e.header),m?{...C,key:n}:C}async function pe(e,t,n){if(e instanceof Uint8Array&&(e=r.decode(e)),"string"!=typeof e)throw new l("Compact JWE must be a string or Uint8Array");const{0:a,1:o,2:i,3:s,4:c,length:d}=e.split(".");if(5!==d)throw new l("Invalid Compact JWE");const p=await de({ciphertext:s||void 0,iv:i||void 0,protected:a||void 0,tag:c||void 0,encrypted_key:o||void 0},t,n),h={plaintext:p.plaintext,protectedHeader:p.protectedHeader};return"function"==typeof t?{...h,key:p.key}:h}var he=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:d(e)};if(!A(e))throw new TypeError(D(e,...T,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:r,alg:n,use:a,...o}=await m.subtle.exportKey("jwk",e);return o};async function ye(e){return he(e)}async function ue(e,t,r,n,a={}){let o,i,s;switch(ae(e,r,"encrypt"),e){case"dir":s=r;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!q(r))throw new u("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const{apu:c,apv:p}=a;let{epk:h}=a;h||(h=await(async e=>{if(!A(e))throw new TypeError(D(e,...T));return(await m.subtle.generateKey({name:"ECDH",namedCurve:e.algorithm.namedCurve},!0,["deriveBits"])).privateKey})(r));const{x:y,y:w,crv:l,kty:f}=await ye(h),g=await Y(r,h,"ECDH-ES"===e?t:e,"ECDH-ES"===e?ee(t):parseInt(e.substr(-5,3),10),c,p);if(i={epk:{x:y,y:w,crv:l,kty:f}},c&&(i.apu=d(c)),p&&(i.apv=d(p)),"ECDH-ES"===e){s=g;break}s=n||te(t);const E=e.substr(-6);o=await L(E,g,s);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":s=n||te(t),o=await(async(e,t,r)=>{if(!A(t))throw new TypeError(D(t,...T));if(J(t,e,"encrypt","wrapKey"),Z(e,t),t.usages.includes("encrypt"))return new Uint8Array(await m.subtle.encrypt(Q(e),t,r));if(t.usages.includes("wrapKey")){const n=await m.subtle.importKey("raw",r,...j);return new Uint8Array(await m.subtle.wrapKey("raw",n,t,Q(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,r,s);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{s=n||te(t);const{p2c:c,p2s:p}=a;({encryptedKey:o,...i}=await(async(e,t,r,n=Math.floor(2049*Math.random())+2048,a=S(new Uint8Array(16)))=>{const o=await X(a,e,n,t);return{encryptedKey:await L(e.substr(-6),o,r),p2c:n,p2s:d(a)}})(e,r,s,c,p));break}case"A128KW":case"A192KW":case"A256KW":s=n||te(t),o=await L(e,r,s);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{s=n||te(t);const{iv:c}=a;({encryptedKey:o,...i}=await async function(e,t,r,n){const a=e.substr(0,7);n||(n=v(a));const{ciphertext:o,tag:i}=await oe(a,r,t,n,new Uint8Array(0));return{encryptedKey:o,iv:d(n),tag:d(i)}}(e,r,s,c));break}default:throw new u('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:s,encryptedKey:o,parameters:i}}const we=Symbol();class le{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,n){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new l("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!$(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new l("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const o={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(se(l,new Map,null==n?void 0:n.crit,this._protectedHeader,o),void 0!==o.zip){if(!this._protectedHeader||!this._protectedHeader.zip)throw new l('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==o.zip)throw new u('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:i,enc:s}=o;if("string"!=typeof i||!i)throw new l('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof s||!s)throw new l('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let c,p,h,y,w,f,g;if("dir"===i){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if("ECDH-ES"===i&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");{let t;({cek:p,encryptedKey:c,parameters:t}=await ue(i,s,e,this._cek,this._keyManagementParameters)),t&&(n&&we in n?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...t}:this.setUnprotectedHeader(t):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...t}:this.setProtectedHeader(t))}if(this._iv||(this._iv=v(s)),y=this._protectedHeader?t.encode(d(JSON.stringify(this._protectedHeader))):t.encode(""),this._aad?(w=d(this._aad),h=a(y,t.encode("."),t.encode(w))):h=y,"DEF"===o.zip){const e=await((null==n?void 0:n.deflateRaw)||B)(this._plaintext);({ciphertext:f,tag:g}=await oe(s,e,p,this._iv,h))}else({ciphertext:f,tag:g}=await oe(s,this._plaintext,p,this._iv,h));const E={ciphertext:d(f),iv:d(this._iv),tag:d(g)};return c&&(E.encrypted_key=d(c)),w&&(E.aad=w),this._protectedHeader&&(E.protected=r.decode(y)),this._sharedUnprotectedHeader&&(E.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(E.header=this._unprotectedHeader),E}}function fe(e,t){const r=parseInt(e.substr(-3),10);switch(e){case"HS256":case"HS384":case"HS512":return{hash:`SHA-${r}`,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:`SHA-${r}`,name:"RSA-PSS",saltLength:r>>3};case"RS256":case"RS384":case"RS512":return{hash:`SHA-${r}`,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:`SHA-${r}`,name:"ECDSA",namedCurve:t};case(P()||K())&&"EdDSA":return{name:t,namedCurve:t};default:throw new u(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function ge(e,t,r){if(A(t))return R(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(D(t,...T));return m.subtle.importKey("raw",t,{hash:`SHA-${e.substr(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(D(t,...T,"Uint8Array"))}async function Ee(e,n,o){var i;if(!G(e))throw new f("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new f('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new f("JWS Protected Header incorrect type");if(void 0===e.payload)throw new f("JWS Payload missing");if("string"!=typeof e.signature)throw new f("JWS Signature missing or incorrect type");if(void 0!==e.header&&!G(e.header))throw new f("JWS Unprotected Header incorrect type");let s={};if(e.protected){const t=p(e.protected);try{s=JSON.parse(r.decode(t))}catch(e){throw new f("JWS Protected Header is invalid")}}if(!$(s,e.header))throw new f("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const c={...s,...e.header};let d=!0;if(se(f,new Map([["b64",!0]]),null==o?void 0:o.crit,s,c).has("b64")&&(d=s.b64,"boolean"!=typeof d))throw new f('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:h}=c;if("string"!=typeof h||!h)throw new f('JWS "alg" (Algorithm) Header Parameter missing or invalid');const u=o&&ce("algorithms",o.algorithms);if(u&&!u.has(h))throw new y('"alg" (Algorithm) Header Parameter not allowed');if(d){if("string"!=typeof e.payload)throw new f("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new f("JWS Payload must be a string or an Uint8Array instance");let w=!1;"function"==typeof n&&(n=await n(s,e),w=!0),ae(h,n,"verify");const l=a(t.encode(null!==(i=e.protected)&&void 0!==i?i:""),t.encode("."),"string"==typeof e.payload?t.encode(e.payload):e.payload),g=p(e.signature),A=await(async(e,t,r,n)=>{const a=await ge(e,t,"verify");Z(e,a);const o=fe(e,a.algorithm.namedCurve);try{return await m.subtle.verify(o,a,r,n)}catch(e){return!1}})(h,n,g,l);if(!A)throw new E;let S;S=d?p(e.payload):"string"==typeof e.payload?t.encode(e.payload):e.payload;const b={payload:S};return void 0!==e.protected&&(b.protectedHeader=s),void 0!==e.header&&(b.unprotectedHeader=e.header),w?{...b,key:n}:b}async function me(e,t,n){if(e instanceof Uint8Array&&(e=r.decode(e)),"string"!=typeof e)throw new f("Compact JWS must be a string or Uint8Array");const{0:a,1:o,2:i,length:s}=e.split(".");if(3!==s)throw new f("Invalid Compact JWS");const c=await Ee({payload:o,protected:a,signature:i},t,n),d={payload:c.payload,protectedHeader:c.protectedHeader};return"function"==typeof t?{...d,key:c.key}:d}class Ae{constructor(e){this._flattened=new le(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}class Se{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,n){if(!this._protectedHeader&&!this._unprotectedHeader)throw new f("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!$(this._protectedHeader,this._unprotectedHeader))throw new f("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const o={...this._protectedHeader,...this._unprotectedHeader};let i=!0;if(se(f,new Map([["b64",!0]]),null==n?void 0:n.crit,this._protectedHeader,o).has("b64")&&(i=this._protectedHeader.b64,"boolean"!=typeof i))throw new f('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=o;if("string"!=typeof s||!s)throw new f('JWS "alg" (Algorithm) Header Parameter missing or invalid');ae(s,e,"sign");let c,p=this._payload;i&&(p=t.encode(d(p))),c=this._protectedHeader?t.encode(d(JSON.stringify(this._protectedHeader))):t.encode("");const h=a(c,t.encode("."),p),y=await(async(e,t,r)=>{const n=await ge(e,t,"sign");Z(e,n);const a=await m.subtle.sign(fe(e,n.algorithm.namedCurve),n,r);return new Uint8Array(a)})(s,e,h),u={signature:d(y),payload:""};return i&&(u.payload=r.decode(p)),this._unprotectedHeader&&(u.header=this._unprotectedHeader),this._protectedHeader&&(u.protected=r.decode(c)),u}}class be{constructor(e){this._flattened=new Se(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}const ve=(e,t)=>{if("string"!=typeof e||!e)throw new g(`${t} missing or invalid`)};const He=async function(e,t="SHA-256"){const r=["SHA-1","SHA-256","SHA-384","SHA-512"];if(!r.includes(t))throw new RangeError(`Valid hash algorith values are any of ${JSON.stringify(r)}`);const n=new TextEncoder,a="string"==typeof e?n.encode(e).buffer:e;let o="";{const e=await crypto.subtle.digest(t,a),r="0123456789abcdef";new Uint8Array(e).forEach((e=>{o+=r[e>>4]+r[15&e]}))}return o},Ce=async(e,t)=>{const{payload:r}=await me(t,e).catch((e=>{throw new Error(`PoR: ${String(e)}`)}));return JSON.parse((new TextDecoder).decode(r).toString())},Pe=async(e,t)=>{const{payload:r}=await me(t,e).catch((e=>{throw new Error("PoO "+String(e))}));return JSON.parse((new TextDecoder).decode(r).toString())},Ke=async(e,t)=>{const r=new TextDecoder,n=await ne(t,"A256GCM"),{plaintext:a}=await pe(e,n);return r.decode(a)},_e="ES256",We=async(e,t)=>{const r=(new TextEncoder).encode(JSON.stringify(t));return await new be(r).setProtectedHeader({alg:_e}).sign(e)};e.SIGNING_ALG=_e,e.createBlockchainProof=async(e,t,r,n)=>{const a=await Pe(e,t);return{privateStorage:{availability:"privateStorage",permissions:{view:[a.exchange.orig,a.exchange.dest]},type:"dict",id:a.exchange.id,content:{[a.exchange.block_id]:{poO:t,poR:r}}},blockchain:{availability:"blockchain",type:"jwk",content:{[n.kid]:n}}}},e.createJwk=async()=>{let e;e=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);const r=await ye(e),n=await async function(e,r="sha256"){if(!G(e))throw new TypeError("JWK must be an object");let n;switch(e.kty){case"EC":ve(e.crv,'"crv" (Curve) Parameter'),ve(e.x,'"x" (X Coordinate) Parameter'),ve(e.y,'"y" (Y Coordinate) Parameter'),n={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":ve(e.crv,'"crv" (Subtype of Key Pair) Parameter'),ve(e.x,'"x" (Public Key) Parameter'),n={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":ve(e.e,'"e" (Exponent) Parameter'),ve(e.n,'"n" (Modulus) Parameter'),n={e:e.e,kty:e.kty,n:e.n};break;case"oct":ve(e.k,'"k" (Key Value) Parameter'),n={k:e.k,kty:e.kty};break;default:throw new u('"kty" (Key Type) Parameter missing or unsupported')}const a=t.encode(JSON.stringify(n));return d(await V(r,a))}(r);return r.kid=n,r.alg="A256GCM",r},e.createPoO=async(e,t,r,n,a,o,i)=>{const s="string"==typeof t?(new TextEncoder).encode(t):new Uint8Array(t),c=await ne(i),d=await new Ae(s).setProtectedHeader({alg:"dir",enc:"A256GCM"}).encrypt(c),p=await He(d),h=await He(s),y=await He(JSON.stringify(i)),u={iss:r,sub:n,iat:Date.now(),exchange:{id:a,orig:r,dest:n,block_id:o,block_desc:"description",hash_alg:"sha256",cipherblock_dgst:p,block_commitment:h,key_commitment:y}};return{cipherblock:d,poO:await We(e,u)}},e.createPoR=async(e,t,r,n,a)=>{const o=await He(t),i={iss:r,sub:n,iat:Date.now(),exchange:{poo_dgst:o,hash_alg:"sha256",exchangeId:a}};return await We(e,i)},e.decodePoo=Pe,e.decodePor=Ce,e.decryptCipherblock=Ke,e.sha=He,e.signProof=We,e.validateCipherblock=async(e,t,r,n)=>{const a=await Ke(t,r);if(await He(a)===n.exchange.block_commitment)return!0;throw new Error("hashed CipherBlock not correspond to block_commitment parameter included in the proof of origin")},e.validatePoO=async(e,t,r)=>{const n=await Pe(e,t),a=await He(r);if(n.exchange.cipherblock_dgst!==a)throw new Error("the cipherblock_dgst parameter in the proof of origin does not correspond to hash of the cipherblock received by the provider");if(Date.now()-n.iat>5e3)throw new Error("timestamp error");return!0},e.validatePoP=(e,t,r,n,a)=>new Promise(((o,i)=>{me(r,e).catch((e=>{i(new Error("PoP "+String(e)))})),Pe(t,a).then((e=>{He(JSON.stringify(n)).then((t=>{e.exchange.key_commitment===t?o(!0):i(new Error("hashed key not correspond to poO key_commitment parameter"))})).catch((e=>i(e)))})).catch((e=>i(e)))})),e.validatePoR=async(e,t,r)=>{const n=await Ce(e,t);if(await He(r)!==n.exchange.poo_dgst)throw new Error("the hashed proof of origin received does not correspond to the poo_dgst parameter in the proof of origin");if(Date.now()-n.iat>5e3)throw new Error("timestamp error");return!0},Object.defineProperty(e,"__esModule",{value:!0})}));
