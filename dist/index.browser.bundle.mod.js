class e extends Error{constructor(e){super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}}class t extends e{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}}class r extends e{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}}const a=new TextEncoder,s=new TextDecoder;var n=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;throw new Error("unable to locate global object")}();const o=e=>{let t=e;"string"==typeof t&&(t=a.encode(t));const r=[];for(let e=0;e<t.length;e+=32768)r.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return n.btoa(r.join("")).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")},c=e=>{let t=e;t instanceof Uint8Array&&(t=s.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return new Uint8Array(n.atob(t).split("").map((e=>e.charCodeAt(0))))}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};var i=n.crypto;function d(){if(!n.isSecureContext&&!n.crypto.subtle)throw new e("Web Cryptography API is available only in Secure Contexts. See: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts")}const h=async(e,r,a)=>{let s;if(d(),r instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError("symmetric keys are only applicable for HMAC-based algorithms");s=await i.subtle.importKey("raw",r,{hash:`SHA-${e.substr(-3)}`,name:"HMAC"},!1,["sign"])}else s=r;((e,t)=>{if(e.startsWith("HS")){const r=parseInt(e.substr(-3),10),{length:a}=t.algorithm;if("number"!=typeof a||a<r)throw new TypeError(`${e} requires symmetric keys to be ${r} bits or larger`)}if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}})(e,s);const n=await i.subtle.sign(function(e){switch(e){case"HS256":return{hash:"SHA-256",name:"HMAC"};case"HS384":return{hash:"SHA-384",name:"HMAC"};case"HS512":return{hash:"SHA-512",name:"HMAC"};case"PS256":return{hash:"SHA-256",name:"RSA-PSS",saltLength:32};case"PS384":return{hash:"SHA-384",name:"RSA-PSS",saltLength:48};case"PS512":return{hash:"SHA-512",name:"RSA-PSS",saltLength:64};case"RS256":return{hash:"SHA-256",name:"RSASSA-PKCS1-v1_5"};case"RS384":return{hash:"SHA-384",name:"RSASSA-PKCS1-v1_5"};case"RS512":return{hash:"SHA-512",name:"RSASSA-PKCS1-v1_5"};case"ES256":return{hash:"SHA-256",name:"ECDSA",namedCurve:"P-256"};case"ES384":return{hash:"SHA-384",name:"ECDSA",namedCurve:"P-384"};case"ES512":return{hash:"SHA-512",name:"ECDSA",namedCurve:"P-521"};default:throw new t(`alg ${e} is unsupported either by JOSE or your javascript runtime`)}}(e),s,a);return new Uint8Array(n)};const l=function(e,r,a,s,n){if(void 0!==n.crit&&void 0===s.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!s||void 0===s.crit)return new Set;if(!Array.isArray(s.crit)||0===s.crit.length||s.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;o=void 0!==a?new Map([...Object.entries(a),...r.entries()]):r;for(const r of s.crit){if(!o.has(r))throw new t(`Extension Header Parameter "${r}" is not recognized`);if(void 0===n[r])throw new e(`Extension Header Parameter "${r}" is missing`);if(o.get(r)&&void 0===s[r])throw new e(`Extension Header Parameter "${r}" MUST be integrity protected`)}return new Set(s.crit)}.bind(void 0,r,new Map([["b64",!0]]));class u{constructor(e){this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){if(!this._protectedHeader&&!this._unprotectedHeader)throw new r("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!((...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0})(this._protectedHeader,this._unprotectedHeader))throw new r("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const n={...this._protectedHeader,...this._unprotectedHeader};let c=!0;if(l(null==t?void 0:t.crit,this._protectedHeader,n).has("b64")&&(c=this._protectedHeader.b64,"boolean"!=typeof c))throw new r('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=n;if("string"!=typeof i||!i)throw new r('JWS "alg" (Algorithm) Header Parameter missing or invalid');((e,t)=>{if(e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||e.match(/^A\d{3}(?:GCM)KW$/)){if(t instanceof Uint8Array||"secret"===t.type)return;throw new TypeError('CryptoKey or KeyObject instances for symmetric algorithms must be of type "secret"')}if(t instanceof Uint8Array)throw new TypeError("CryptoKey or KeyObject instances must be used for asymmetric algorithms");if("secret"===t.type)throw new TypeError('CryptoKey or KeyObject instances for asymmetric algorithms must not be of type "secret"')})(i,e);let d,u=this._payload;c&&(u=a.encode(o(u))),d=this._protectedHeader?a.encode(o(JSON.stringify(this._protectedHeader))):a.encode("");const S=function(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let a=0;return e.forEach((e=>{r.set(e,a),a+=e.length})),r}(d,a.encode("."),u),p=await h(i,e,S),y={signature:o(p)};return c&&(y.payload=s.decode(u)),this._unprotectedHeader&&(y.header=this._unprotectedHeader),this._protectedHeader&&(y.protected=s.decode(d)),y}}class S{constructor(e){this._flattened=new u(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}const p=async e=>{var r,a;const{algorithm:s,keyUsages:n}=function(e){let r,a;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":r={name:"HMAC",hash:`SHA-${e.alg.substr(-3)}`},a=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new t(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":r={name:"AES-GCM"},a=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":r={name:"AES-KW"},a=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":r={name:"PBKDF2"},a=["deriveBits"];break;default:throw new t('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":r={name:"RSA-PSS",hash:`SHA-${e.alg.substr(-3)}`},a=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":r={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.substr(-3)}`},a=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":r={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.substr(-3),10)||1}`},a=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new t('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":case"ES384":case"ES512":r={name:"ECDSA",namedCurve:e.crv},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":r={name:"ECDH",namedCurve:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new t('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;default:throw new t('unsupported or invalid JWK "kty" (Key Type) Parameter value')}return{algorithm:r,keyUsages:a}}(e);let o="jwk",h={...e};return delete h.alg,"PBKDF2"===s.name&&(o="raw",h=c(e.k)),d(),i.subtle.importKey(o,h,s,null!==(r=e.ext)&&void 0!==r&&r,null!==(a=e.key_ops)&&void 0!==a?a:n)};async function y(e,r,a){if(!(s=e)||s.constructor!==Object)throw new TypeError("JWK must be an object");var s;if(r||(r=e.alg),"string"!=typeof r||!r)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=a||(a=!0!==e.ext),a?p({...e,alg:r,ext:!1}):c(e.k);case"RSA":if(void 0!==e.oth)throw new t('RSA JWK "oth" (Other Primes Info) Parameter value is unsupported');case"EC":case"OKP":return p({...e,alg:r});default:throw new t('unsupported "kty" (Key Type) Parameter value')}}function w(e){return console.log("Browser echoes: "+e),e}async function g(e){const t=new TextEncoder,r=await y({alg:"ES256",crv:"P-256",kty:"EC",d:"VhsfgSRKcvHCGpLyygMbO_YpXc7bVKwi12KQTE4yOR4",x:"ySK38C1jBdLwDsNWKzzBHqKYEE5Cgv-qjWvorUXk9fw",y:"_LeQBw07cf5t57Iavn4j-BqJsAD1dpoz8gokd3sBsOo"}),a=await new S(t.encode(JSON.stringify({msg:"Itâ€™s a dangerous business, Frodo, going out your door."}))).setProtectedHeader({alg:"ES256"}).sign(r);return console.log(a),a}export{w as echo,g as sign};
