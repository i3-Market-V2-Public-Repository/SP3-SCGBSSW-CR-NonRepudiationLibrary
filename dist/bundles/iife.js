var nonRepudiationProofs=function(e){"use strict";const t=new TextEncoder,r=new TextDecoder,a=2**32;function n(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let a=0;return e.forEach((e=>{r.set(e,a),a+=e.length})),r}function i(e,t,r){if(t<0||t>=a)throw new RangeError(`value must be >= 0 and <= 4294967295. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function o(e){const t=Math.floor(e/a),r=e%a,n=new Uint8Array(8);return i(n,t,0),i(n,r,4),n}function s(e){const t=new Uint8Array(4);return i(t,e),t}function c(e){return n(s(e.length),e)}const d=e=>(e=>{let r=e;"string"==typeof r&&(r=t.encode(r));const a=[];for(let e=0;e<r.length;e+=32768)a.push(String.fromCharCode.apply(null,r.subarray(e,e+32768)));return btoa(a.join(""))})(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),h=e=>{let t=e;t instanceof Uint8Array&&(t=r.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>new Uint8Array(atob(e).split("").map((e=>e.charCodeAt(0)))))(t)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class p extends Error{constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}static get code(){return"ERR_JOSE_GENERIC"}}class u extends p{constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=t,this.reason=r}static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}}class l extends p{constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=t,this.reason=r}static get code(){return"ERR_JWT_EXPIRED"}}class y extends p{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class w extends p{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class f extends p{constructor(){super(...arguments),this.code="ERR_JWE_DECRYPTION_FAILED",this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class g extends p{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class m extends p{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class E extends p{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class A extends p{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}static get code(){return"ERR_JWK_INVALID"}}class b extends p{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var S=crypto;function v(e){try{return null!=e&&"boolean"==typeof e.extractable&&"string"==typeof e.algorithm.name&&"string"==typeof e.type}catch(e){return!1}}var H=S.getRandomValues.bind(S);function k(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new w(`Unsupported JWE Algorithm: ${e}`)}}var P=e=>H(new Uint8Array(k(e)>>3));const C=(e,t)=>{if(t.length<<3!==k(e))throw new g("Invalid Initialization Vector length")},_=(e,t)=>{if(e.length<<3!==t)throw new g("Invalid Content Encryption Key length")};function K(){return"function"==typeof WebSocketPair}function W(){try{return void 0!==process.versions.node}catch(e){return!1}}function J(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function O(e,t){return e.name===t}function R(e){return parseInt(e.name.substr(4),10)}function T(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function D(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!O(e.algorithm,"HMAC"))throw J("HMAC");const r=parseInt(t.substr(2),10);if(R(e.algorithm.hash)!==r)throw J(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!O(e.algorithm,"RSASSA-PKCS1-v1_5"))throw J("RSASSA-PKCS1-v1_5");const r=parseInt(t.substr(2),10);if(R(e.algorithm.hash)!==r)throw J(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!O(e.algorithm,"RSA-PSS"))throw J("RSA-PSS");const r=parseInt(t.substr(2),10);if(R(e.algorithm.hash)!==r)throw J(`SHA-${r}`,"algorithm.hash");break}case W()&&"EdDSA":if("NODE-ED25519"!==e.algorithm.name&&"NODE-ED448"!==e.algorithm.name)throw J("NODE-ED25519 or NODE-ED448");break;case K()&&"EdDSA":if(!O(e.algorithm,"NODE-ED25519"))throw J("NODE-ED25519");break;case"ES256":case"ES384":case"ES512":{if(!O(e.algorithm,"ECDSA"))throw J("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw J(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}T(e,r)}function U(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!O(e.algorithm,"AES-GCM"))throw J("AES-GCM");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw J(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!O(e.algorithm,"AES-KW"))throw J("AES-KW");const r=parseInt(t.substr(1,3),10);if(e.algorithm.length!==r)throw J(r,"algorithm.length");break}case"ECDH-ES":if(!O(e.algorithm,"ECDH"))throw J("ECDH");break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!O(e.algorithm,"PBKDF2"))throw J("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!O(e.algorithm,"RSA-OAEP"))throw J("RSA-OAEP");const r=parseInt(t.substr(9),10)||1;if(R(e.algorithm.hash)!==r)throw J(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}T(e,r)}var x=(e,...t)=>{let r="Key must be ";if(t.length>2){const e=t.pop();r+=`one of type ${t.join(", ")}, or ${e}.`}else 2===t.length?r+=`one of type ${t[0]} or ${t[1]}.`:r+=`of type ${t[0]}.`;return null==e?r+=` Received ${e}`:"function"==typeof e&&e.name?r+=` Received function ${e.name}`:"object"==typeof e&&null!=e&&e.constructor&&e.constructor.name&&(r+=` Received an instance of ${e.constructor.name}`),r},I=e=>v(e);const M=["CryptoKey"];async function N(e,t,r,a,i,s){if(!(t instanceof Uint8Array))throw new TypeError(x(t,"Uint8Array"));const c=parseInt(e.substr(1,3),10),d=await S.subtle.importKey("raw",t.subarray(c>>3),"AES-CBC",!1,["decrypt"]),h=await S.subtle.importKey("raw",t.subarray(0,c>>3),{hash:"SHA-"+(c<<1),name:"HMAC"},!1,["sign"]),p=n(s,a,r,o(s.length<<3)),u=new Uint8Array((await S.subtle.sign("HMAC",h,p)).slice(0,c>>3));let l,y;try{l=((e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let a=0,n=-1;for(;++n<r;)a|=e[n]^t[n];return 0===a})(i,u)}catch(e){}if(!l)throw new f;try{y=new Uint8Array(await S.subtle.decrypt({iv:a,name:"AES-CBC"},d,r))}catch(e){}if(!y)throw new f;return y}const j=async(e,t,r,a,i,o)=>{if(!(v(t)||t instanceof Uint8Array))throw new TypeError(x(t,...M,"Uint8Array"));switch(C(e,a),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return t instanceof Uint8Array&&_(t,parseInt(e.substr(-3),10)),N(e,t,r,a,i,o);case"A128GCM":case"A192GCM":case"A256GCM":return t instanceof Uint8Array&&_(t,parseInt(e.substr(1,3),10)),async function(e,t,r,a,i,o){let s;t instanceof Uint8Array?s=await S.subtle.importKey("raw",t,"AES-GCM",!1,["decrypt"]):(U(t,e,"decrypt"),s=t);try{return new Uint8Array(await S.subtle.decrypt({additionalData:o,iv:a,name:"AES-GCM",tagLength:128},s,n(r,i)))}catch(e){throw new f}}(e,t,r,a,i,o);default:throw new w("Unsupported JWE Content Encryption Algorithm")}},$=async()=>{throw new w('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.')},B=async()=>{throw new w('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.')},G=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0};function L(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const z=[{hash:"SHA-256",name:"HMAC"},!0,["sign"]];function F(e,t){if(e.algorithm.length!==parseInt(t.substr(1,3),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function V(e,t,r){if(v(e))return U(e,t,r),e;if(e instanceof Uint8Array)return S.subtle.importKey("raw",e,"AES-KW",!0,[r]);throw new TypeError(x(e,...M,"Uint8Array"))}const Y=async(e,t,r)=>{const a=await V(t,e,"wrapKey");F(a,e);const n=await S.subtle.importKey("raw",r,...z);return new Uint8Array(await S.subtle.wrapKey("raw",n,a,"AES-KW"))},q=async(e,t,r)=>{const a=await V(t,e,"unwrapKey");F(a,e);const n=await S.subtle.unwrapKey("raw",r,a,"AES-KW",...z);return new Uint8Array(await S.subtle.exportKey("raw",n))},X=async(e,t)=>{const r=`SHA-${e.substr(-3)}`;return new Uint8Array(await S.subtle.digest(r,t))},Z=async(e,r,a,i,o=new Uint8Array(0),d=new Uint8Array(0))=>{if(!v(e))throw new TypeError(x(e,...M));if(U(e,"ECDH-ES"),!v(r))throw new TypeError(x(r,...M));U(r,"ECDH-ES","deriveBits","deriveKey");const h=n(c(t.encode(a)),c(o),c(d),s(i));if(!r.usages.includes("deriveBits"))throw new TypeError('ECDH-ES private key "usages" must include "deriveBits"');const p=new Uint8Array(await S.subtle.deriveBits({name:"ECDH",public:e},r,Math.ceil(parseInt(r.algorithm.namedCurve.substr(-3),10)/8)<<3));return async function(e,t,r,a){const i=Math.ceil((r>>3)/32);let o;for(let r=1;r<=i;r++){const i=new Uint8Array(4+t.length+a.length);i.set(s(r)),i.set(t,4),i.set(a,4+t.length),o=o?n(o,await e("sha256",i)):await e("sha256",i)}return o=o.slice(0,r>>3),o}(X,p,i,h)},Q=e=>{if(!v(e))throw new TypeError(x(e,...M));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)};async function ee(e,r,a,i){!function(e){if(!(e instanceof Uint8Array)||e.length<8)throw new g("PBES2 Salt Input must be 8 or more octets")}(e);const o=function(e,r){return n(t.encode(e),new Uint8Array([0]),r)}(r,e),s=parseInt(r.substr(13,3),10),c={hash:`SHA-${r.substr(8,3)}`,iterations:a,name:"PBKDF2",salt:o},d={length:s,name:"AES-KW"},h=await function(e,t){if(e instanceof Uint8Array)return S.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]);if(v(e))return U(e,t,"deriveBits","deriveKey"),e;throw new TypeError(x(e,...M,"Uint8Array"))}(i,r);if(h.usages.includes("deriveBits"))return new Uint8Array(await S.subtle.deriveBits(c,h,s));if(h.usages.includes("deriveKey"))return S.subtle.deriveKey(c,h,d,!1,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}function te(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new w(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var re=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function ae(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new w(`Unsupported JWE Algorithm: ${e}`)}}var ne=e=>H(new Uint8Array(ae(e)>>3));var ie=async e=>{var t,r;const{algorithm:a,keyUsages:n}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.substr(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new w(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.substr(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.substr(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case(K()||W())&&"OKP":if("EdDSA"!==e.alg)throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');switch(e.crv){case"Ed25519":t={name:"NODE-ED25519",namedCurve:"NODE-ED25519"},r=e.d?["sign"]:["verify"];break;case W()&&"Ed448":t={name:"NODE-ED448",namedCurve:"NODE-ED448"},r=e.d?["sign"]:["verify"];break;default:throw new w('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value')}break;default:throw new w('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),i=[a,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:n];if("PBKDF2"===a.name)return S.subtle.importKey("raw",h(e.k),...i);const o={...e};return delete o.alg,S.subtle.importKey("jwk",o,...i)};async function oe(e,t,r){if(!L(e))throw new TypeError("JWK must be an object");if(t||(t=e.alg),"string"!=typeof t||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?ie({...e,alg:t,ext:!1}):h(e.k);case"RSA":if(void 0!==e.oth)throw new w('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return ie({...e,alg:t});default:throw new w('Unsupported "kty" (Key Type) Parameter value')}}const se=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?(e=>{if(!(e instanceof Uint8Array)){if(!I(e))throw new TypeError(x(e,...M,"Uint8Array"));if("secret"!==e.type)throw new TypeError(`${M.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(t):((e,t)=>{if(!I(e))throw new TypeError(x(e,...M));if("secret"===e.type)throw new TypeError(`${M.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===t&&"public"===e.type)throw new TypeError(`${M.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===t&&"public"===e.type)throw new TypeError(`${M.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(e.algorithm&&"verify"===t&&"private"===e.type)throw new TypeError(`${M.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(e.algorithm&&"encrypt"===t&&"private"===e.type)throw new TypeError(`${M.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(t,r)};const ce=async(e,t,r,a,i)=>{if(!(v(r)||r instanceof Uint8Array))throw new TypeError(x(r,...M,"Uint8Array"));switch(C(e,a),e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return r instanceof Uint8Array&&_(r,parseInt(e.substr(-3),10)),async function(e,t,r,a,i){if(!(r instanceof Uint8Array))throw new TypeError(x(r,"Uint8Array"));const s=parseInt(e.substr(1,3),10),c=await S.subtle.importKey("raw",r.subarray(s>>3),"AES-CBC",!1,["encrypt"]),d=await S.subtle.importKey("raw",r.subarray(0,s>>3),{hash:"SHA-"+(s<<1),name:"HMAC"},!1,["sign"]),h=new Uint8Array(await S.subtle.encrypt({iv:a,name:"AES-CBC"},c,t)),p=n(i,a,h,o(i.length<<3));return{ciphertext:h,tag:new Uint8Array((await S.subtle.sign("HMAC",d,p)).slice(0,s>>3))}}(e,t,r,a,i);case"A128GCM":case"A192GCM":case"A256GCM":return r instanceof Uint8Array&&_(r,parseInt(e.substr(1,3),10)),async function(e,t,r,a,n){let i;r instanceof Uint8Array?i=await S.subtle.importKey("raw",r,"AES-GCM",!1,["encrypt"]):(U(r,e,"encrypt"),i=r);const o=new Uint8Array(await S.subtle.encrypt({additionalData:n,iv:a,name:"AES-GCM",tagLength:128},i,t)),s=o.slice(-16);return{ciphertext:o.slice(0,-16),tag:s}}(e,t,r,a,i);default:throw new w("Unsupported JWE Content Encryption Algorithm")}};async function de(e,t,r,a){switch(se(e,t,"decrypt"),e){case"dir":if(void 0!==r)throw new g("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new g("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!L(a.epk))throw new g('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!Q(t))throw new w("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const n=await oe(a.epk,e);let i,o;if(void 0!==a.apu){if("string"!=typeof a.apu)throw new g('JOSE Header "apu" (Agreement PartyUInfo) invalid');i=h(a.apu)}if(void 0!==a.apv){if("string"!=typeof a.apv)throw new g('JOSE Header "apv" (Agreement PartyVInfo) invalid');o=h(a.apv)}const s=await Z(n,t,"ECDH-ES"===e?a.enc:e,"ECDH-ES"===e?ae(a.enc):parseInt(e.substr(-5,3),10),i,o);if("ECDH-ES"===e)return s;if(void 0===r)throw new g("JWE Encrypted Key missing");return q(e.substr(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new g("JWE Encrypted Key missing");return(async(e,t,r)=>{if(!v(t))throw new TypeError(x(t,...M));if(U(t,e,"decrypt","unwrapKey"),re(e,t),t.usages.includes("decrypt"))return new Uint8Array(await S.subtle.decrypt(te(e),t,r));if(t.usages.includes("unwrapKey")){const a=await S.subtle.unwrapKey("raw",r,t,te(e),...z);return new Uint8Array(await S.subtle.exportKey("raw",a))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')})(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(void 0===r)throw new g("JWE Encrypted Key missing");if("number"!=typeof a.p2c)throw new g('JOSE Header "p2c" (PBES2 Count) missing or invalid');if("string"!=typeof a.p2s)throw new g('JOSE Header "p2s" (PBES2 Salt) missing or invalid');return(async(e,t,r,a,n)=>{const i=await ee(n,e,a,t);return q(e.substr(-6),i,r)})(e,t,r,a.p2c,h(a.p2s));case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new g("JWE Encrypted Key missing");return q(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":if(void 0===r)throw new g("JWE Encrypted Key missing");if("string"!=typeof a.iv)throw new g('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!=typeof a.tag)throw new g('JOSE Header "tag" (Authentication Tag) missing or invalid');return async function(e,t,r,a,n){const i=e.substr(0,7);return j(i,t,r,a,n,new Uint8Array(0))}(e,t,r,h(a.iv),h(a.tag));default:throw new w('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function he(e,t,r,a,n){if(void 0!==n.crit&&void 0===a.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!a||void 0===a.crit)return new Set;if(!Array.isArray(a.crit)||0===a.crit.length||a.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;i=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of a.crit){if(!i.has(t))throw new w(`Extension Header Parameter "${t}" is not recognized`);if(void 0===n[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(i.get(t)&&void 0===a[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(a.crit)}const pe=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function ue(e,a,i){var o;if(!L(e))throw new g("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new g("JOSE Header missing");if("string"!=typeof e.iv)throw new g("JWE Initialization Vector missing or incorrect type");if("string"!=typeof e.ciphertext)throw new g("JWE Ciphertext missing or incorrect type");if("string"!=typeof e.tag)throw new g("JWE Authentication Tag missing or incorrect type");if(void 0!==e.protected&&"string"!=typeof e.protected)throw new g("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!=typeof e.encrypted_key)throw new g("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!=typeof e.aad)throw new g("JWE AAD incorrect type");if(void 0!==e.header&&!L(e.header))throw new g("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!L(e.unprotected))throw new g("JWE Per-Recipient Unprotected Header incorrect type");let s;if(e.protected){const t=h(e.protected);try{s=JSON.parse(r.decode(t))}catch(e){throw new g("JWE Protected Header is invalid")}}if(!G(s,e.header,e.unprotected))throw new g("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const c={...s,...e.header,...e.unprotected};if(he(g,new Map,null==i?void 0:i.crit,s,c),void 0!==c.zip){if(!s||!s.zip)throw new g('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==c.zip)throw new w('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:d,enc:p}=c;if("string"!=typeof d||!d)throw new g("missing JWE Algorithm (alg) in JWE Header");if("string"!=typeof p||!p)throw new g("missing JWE Encryption Algorithm (enc) in JWE Header");const u=i&&pe("keyManagementAlgorithms",i.keyManagementAlgorithms),l=i&&pe("contentEncryptionAlgorithms",i.contentEncryptionAlgorithms);if(u&&!u.has(d))throw new y('"alg" (Algorithm) Header Parameter not allowed');if(l&&!l.has(p))throw new y('"enc" (Encryption Algorithm) Header Parameter not allowed');let f;void 0!==e.encrypted_key&&(f=h(e.encrypted_key));let m,E=!1;"function"==typeof a&&(a=await a(s,e),E=!0);try{m=await de(d,a,f,c)}catch(e){if(e instanceof TypeError)throw e;m=ne(p)}const A=h(e.iv),b=h(e.tag),S=t.encode(null!==(o=e.protected)&&void 0!==o?o:"");let v;v=void 0!==e.aad?n(S,t.encode("."),t.encode(e.aad)):S;let H=await j(p,m,h(e.ciphertext),A,b,v);"DEF"===c.zip&&(H=await((null==i?void 0:i.inflateRaw)||$)(H));const k={plaintext:H};return void 0!==e.protected&&(k.protectedHeader=s),void 0!==e.aad&&(k.additionalAuthenticatedData=h(e.aad)),void 0!==e.unprotected&&(k.sharedUnprotectedHeader=e.unprotected),void 0!==e.header&&(k.unprotectedHeader=e.header),E?{...k,key:a}:k}var le=async e=>{if(e instanceof Uint8Array)return{kty:"oct",k:d(e)};if(!v(e))throw new TypeError(x(e,...M,"Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:t,key_ops:r,alg:a,use:n,...i}=await S.subtle.exportKey("jwk",e);return i};async function ye(e){return le(e)}async function we(e,t,r,a,n={}){let i,o,s;switch(se(e,r,"encrypt"),e){case"dir":s=r;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!Q(r))throw new w("ECDH-ES with the provided key is not allowed or not supported by your javascript runtime");const{apu:c,apv:h}=n;let{epk:p}=n;p||(p=await(async e=>{if(!v(e))throw new TypeError(x(e,...M));return(await S.subtle.generateKey({name:"ECDH",namedCurve:e.algorithm.namedCurve},!0,["deriveBits"])).privateKey})(r));const{x:u,y:l,crv:y,kty:f}=await ye(p),g=await Z(r,p,"ECDH-ES"===e?t:e,"ECDH-ES"===e?ae(t):parseInt(e.substr(-5,3),10),c,h);if(o={epk:{x:u,y:l,crv:y,kty:f}},c&&(o.apu=d(c)),h&&(o.apv=d(h)),"ECDH-ES"===e){s=g;break}s=a||ne(t);const m=e.substr(-6);i=await Y(m,g,s);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":s=a||ne(t),i=await(async(e,t,r)=>{if(!v(t))throw new TypeError(x(t,...M));if(U(t,e,"encrypt","wrapKey"),re(e,t),t.usages.includes("encrypt"))return new Uint8Array(await S.subtle.encrypt(te(e),t,r));if(t.usages.includes("wrapKey")){const a=await S.subtle.importKey("raw",r,...z);return new Uint8Array(await S.subtle.wrapKey("raw",a,t,te(e)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')})(e,r,s);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{s=a||ne(t);const{p2c:c,p2s:h}=n;({encryptedKey:i,...o}=await(async(e,t,r,a=Math.floor(2049*Math.random())+2048,n=H(new Uint8Array(16)))=>{const i=await ee(n,e,a,t);return{encryptedKey:await Y(e.substr(-6),i,r),p2c:a,p2s:d(n)}})(e,r,s,c,h));break}case"A128KW":case"A192KW":case"A256KW":s=a||ne(t),i=await Y(e,r,s);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{s=a||ne(t);const{iv:c}=n;({encryptedKey:i,...o}=await async function(e,t,r,a){const n=e.substr(0,7);a||(a=P(n));const{ciphertext:i,tag:o}=await ce(n,r,t,a,new Uint8Array(0));return{encryptedKey:i,iv:d(a),tag:d(o)}}(e,r,s,c));break}default:throw new w('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:s,encryptedKey:i,parameters:o}}const fe=Symbol();class ge{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");return this._keyManagementParameters=e,this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");return this._sharedUnprotectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}setAdditionalAuthenticatedData(e){return this._aad=e,this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");return this._cek=e,this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");return this._iv=e,this}async encrypt(e,a){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new g("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!G(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new g("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const i={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};if(he(g,new Map,null==a?void 0:a.crit,this._protectedHeader,i),void 0!==i.zip){if(!this._protectedHeader||!this._protectedHeader.zip)throw new g('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==i.zip)throw new w('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:o,enc:s}=i;if("string"!=typeof o||!o)throw new g('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!=typeof s||!s)throw new g('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let c,h,p,u,l,y,f;if("dir"===o){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if("ECDH-ES"===o&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");{let t;({cek:h,encryptedKey:c,parameters:t}=await we(o,s,e,this._cek,this._keyManagementParameters)),t&&(a&&fe in a?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...t}:this.setUnprotectedHeader(t):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...t}:this.setProtectedHeader(t))}if(this._iv||(this._iv=P(s)),u=this._protectedHeader?t.encode(d(JSON.stringify(this._protectedHeader))):t.encode(""),this._aad?(l=d(this._aad),p=n(u,t.encode("."),t.encode(l))):p=u,"DEF"===i.zip){const e=await((null==a?void 0:a.deflateRaw)||B)(this._plaintext);({ciphertext:y,tag:f}=await ce(s,e,h,this._iv,p))}else({ciphertext:y,tag:f}=await ce(s,this._plaintext,h,this._iv,p));const m={ciphertext:d(y),iv:d(this._iv),tag:d(f)};return c&&(m.encrypted_key=d(c)),l&&(m.aad=l),this._protectedHeader&&(m.protected=r.decode(u)),this._sharedUnprotectedHeader&&(m.unprotected=this._sharedUnprotectedHeader),this._unprotectedHeader&&(m.header=this._unprotectedHeader),m}}function me(e,t){const r=parseInt(e.substr(-3),10);switch(e){case"HS256":case"HS384":case"HS512":return{hash:`SHA-${r}`,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:`SHA-${r}`,name:"RSA-PSS",saltLength:r>>3};case"RS256":case"RS384":case"RS512":return{hash:`SHA-${r}`,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:`SHA-${r}`,name:"ECDSA",namedCurve:t};case(K()||W())&&"EdDSA":return{name:t,namedCurve:t};default:throw new w(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function Ee(e,t,r){if(v(t))return D(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(x(t,...M));return S.subtle.importKey("raw",t,{hash:`SHA-${e.substr(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(x(t,...M,"Uint8Array"))}async function Ae(e,a,i){var o;if(!L(e))throw new m("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new m('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new m("JWS Protected Header incorrect type");if(void 0===e.payload)throw new m("JWS Payload missing");if("string"!=typeof e.signature)throw new m("JWS Signature missing or incorrect type");if(void 0!==e.header&&!L(e.header))throw new m("JWS Unprotected Header incorrect type");let s={};if(e.protected){const t=h(e.protected);try{s=JSON.parse(r.decode(t))}catch(e){throw new m("JWS Protected Header is invalid")}}if(!G(s,e.header))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const c={...s,...e.header};let d=!0;if(he(m,new Map([["b64",!0]]),null==i?void 0:i.crit,s,c).has("b64")&&(d=s.b64,"boolean"!=typeof d))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:p}=c;if("string"!=typeof p||!p)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');const u=i&&pe("algorithms",i.algorithms);if(u&&!u.has(p))throw new y('"alg" (Algorithm) Header Parameter not allowed');if(d){if("string"!=typeof e.payload)throw new m("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new m("JWS Payload must be a string or an Uint8Array instance");let l=!1;"function"==typeof a&&(a=await a(s,e),l=!0),se(p,a,"verify");const w=n(t.encode(null!==(o=e.protected)&&void 0!==o?o:""),t.encode("."),"string"==typeof e.payload?t.encode(e.payload):e.payload),f=h(e.signature),g=await(async(e,t,r,a)=>{const n=await Ee(e,t,"verify");re(e,n);const i=me(e,n.algorithm.namedCurve);try{return await S.subtle.verify(i,n,r,a)}catch(e){return!1}})(p,a,f,w);if(!g)throw new b;let E;E=d?h(e.payload):"string"==typeof e.payload?t.encode(e.payload):e.payload;const A={payload:E};return void 0!==e.protected&&(A.protectedHeader=s),void 0!==e.header&&(A.unprotectedHeader=e.header),l?{...A,key:a}:A}var be=e=>Math.floor(e.getTime()/1e3);const Se=86400,ve=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;var He=e=>{const t=ve.exec(e);if(!t)throw new TypeError("Invalid time period format");const r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(60*r);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(3600*r);case"day":case"days":case"d":return Math.round(r*Se);case"week":case"weeks":case"w":return Math.round(604800*r);default:return Math.round(31557600*r)}};const ke=e=>e.toLowerCase().replace(/^application\//,"");var Pe=(e,t,a={})=>{const{typ:n}=a;if(n&&("string"!=typeof e.typ||ke(e.typ)!==ke(n)))throw new u('unexpected "typ" JWT header value',"typ","check_failed");let i;try{i=JSON.parse(r.decode(t))}catch(e){}if(!L(i))throw new E("JWT Claims Set must be a top-level JSON object");const{issuer:o}=a;if(o&&!(Array.isArray(o)?o:[o]).includes(i.iss))throw new u('unexpected "iss" claim value',"iss","check_failed");const{subject:s}=a;if(s&&i.sub!==s)throw new u('unexpected "sub" claim value',"sub","check_failed");const{audience:c}=a;if(c&&(d=i.aud,h="string"==typeof c?[c]:c,!("string"==typeof d?h.includes(d):Array.isArray(d)&&h.some(Set.prototype.has.bind(new Set(d))))))throw new u('unexpected "aud" claim value',"aud","check_failed");var d,h;let p;switch(typeof a.clockTolerance){case"string":p=He(a.clockTolerance);break;case"number":p=a.clockTolerance;break;case"undefined":p=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:y}=a,w=be(y||new Date);if(void 0!==i.iat||a.maxTokenAge){if("number"!=typeof i.iat)throw new u('"iat" claim must be a number',"iat","invalid");if(void 0===i.exp&&i.iat>w+p)throw new u('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}if(void 0!==i.nbf){if("number"!=typeof i.nbf)throw new u('"nbf" claim must be a number',"nbf","invalid");if(i.nbf>w+p)throw new u('"nbf" claim timestamp check failed',"nbf","check_failed")}if(void 0!==i.exp){if("number"!=typeof i.exp)throw new u('"exp" claim must be a number',"exp","invalid");if(i.exp<=w-p)throw new l('"exp" claim timestamp check failed',"exp","check_failed")}if(a.maxTokenAge){const e=w-i.iat;if(e-p>("number"==typeof a.maxTokenAge?a.maxTokenAge:He(a.maxTokenAge)))throw new l('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(e<0-p)throw new u('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return i};async function Ce(e,t,a){var n;const i=await async function(e,t,a){if(e instanceof Uint8Array&&(e=r.decode(e)),"string"!=typeof e)throw new m("Compact JWS must be a string or Uint8Array");const{0:n,1:i,2:o,length:s}=e.split(".");if(3!==s)throw new m("Invalid Compact JWS");const c=await Ae({payload:i,protected:n,signature:o},t,a),d={payload:c.payload,protectedHeader:c.protectedHeader};return"function"==typeof t?{...d,key:c.key}:d}(e,t,a);if((null===(n=i.protectedHeader.crit)||void 0===n?void 0:n.includes("b64"))&&!1===i.protectedHeader.b64)throw new E("JWTs MUST NOT use unencoded payload");const o={payload:Pe(i.protectedHeader,i.payload,a),protectedHeader:i.protectedHeader};return"function"==typeof t?{...o,key:i.key}:o}class _e{constructor(e){this._flattened=new ge(e)}setContentEncryptionKey(e){return this._flattened.setContentEncryptionKey(e),this}setInitializationVector(e){return this._flattened.setInitializationVector(e),this}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}setKeyManagementParameters(e){return this._flattened.setKeyManagementParameters(e),this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}class Ke{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,a){if(!this._protectedHeader&&!this._unprotectedHeader)throw new m("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!G(this._protectedHeader,this._unprotectedHeader))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...this._protectedHeader,...this._unprotectedHeader};let o=!0;if(he(m,new Map([["b64",!0]]),null==a?void 0:a.crit,this._protectedHeader,i).has("b64")&&(o=this._protectedHeader.b64,"boolean"!=typeof o))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=i;if("string"!=typeof s||!s)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');se(s,e,"sign");let c,h=this._payload;o&&(h=t.encode(d(h))),c=this._protectedHeader?t.encode(d(JSON.stringify(this._protectedHeader))):t.encode("");const p=n(c,t.encode("."),h),u=await(async(e,t,r)=>{const a=await Ee(e,t,"sign");re(e,a);const n=await S.subtle.sign(me(e,a.algorithm.namedCurve),a,r);return new Uint8Array(n)})(s,e,p),l={signature:d(u),payload:""};return o&&(l.payload=r.decode(h)),this._unprotectedHeader&&(l.header=this._unprotectedHeader),this._protectedHeader&&(l.protected=r.decode(c)),l}}class We{constructor(e){this._flattened=new Ke(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}class Je{constructor(e,t,r){this.parent=e,this.key=t,this.options=r}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this.protectedHeader=e,this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this.unprotectedHeader=e,this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class Oe{constructor(e){this._signatures=[],this._payload=e}addSignature(e,t){const r=new Je(this,e,t);return this._signatures.push(r),r}async sign(){if(!this._signatures.length)throw new m("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const r=this._signatures[t],a=new Ke(this._payload);a.setProtectedHeader(r.protectedHeader),a.setUnprotectedHeader(r.unprotectedHeader);const{payload:n,...i}=await a.sign(r.key,r.options);if(0===t)e.payload=n;else if(e.payload!==n)throw new m("inconsistent use of JWS Unencoded Payload Option (RFC7797)");e.signatures.push(i)}return e}}class Re extends class{constructor(e){if(!L(e))throw new TypeError("JWT Claims Set MUST be an object");this._payload=e}setIssuer(e){return this._payload={...this._payload,iss:e},this}setSubject(e){return this._payload={...this._payload,sub:e},this}setAudience(e){return this._payload={...this._payload,aud:e},this}setJti(e){return this._payload={...this._payload,jti:e},this}setNotBefore(e){return this._payload="number"==typeof e?{...this._payload,nbf:e}:{...this._payload,nbf:be(new Date)+He(e)},this}setExpirationTime(e){return this._payload="number"==typeof e?{...this._payload,exp:e}:{...this._payload,exp:be(new Date)+He(e)},this}setIssuedAt(e){return this._payload=void 0===e?{...this._payload,iat:be(new Date)}:{...this._payload,iat:e},this}}{setProtectedHeader(e){return this._protectedHeader=e,this}async sign(e,r){var a;const n=new We(t.encode(JSON.stringify(this._payload)));if(n.setProtectedHeader(this._protectedHeader),Array.isArray(null===(a=this._protectedHeader)||void 0===a?void 0:a.crit)&&this._protectedHeader.crit.includes("b64")&&!1===this._protectedHeader.b64)throw new E("JWTs MUST NOT use unencoded payload");return n.sign(e,r)}}const Te=(e,t)=>{if("string"!=typeof e||!e)throw new A(`${t} missing or invalid`)};async function De(e,t){return async function(e,t){var r;let a,n,i;switch(e){case"HS256":case"HS384":case"HS512":a=parseInt(e.substr(-3),10),n={name:"HMAC",hash:`SHA-${a}`,length:a},i=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return a=parseInt(e.substr(-3),10),H(new Uint8Array(a>>3));case"A128KW":case"A192KW":case"A256KW":a=parseInt(e.substring(1,4),10),n={name:"AES-KW",length:a},i=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":a=parseInt(e.substring(1,4),10),n={name:"AES-GCM",length:a},i=["encrypt","decrypt"];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return S.subtle.generateKey(n,null!==(r=null==t?void 0:t.extractable)&&void 0!==r&&r,i)}(e,t)}async function Ue(e,t,r){const a=await oe(e,r),n=await oe(t,r),i=await function(e,t=!1){if(e<1)throw new RangeError("byteLength MUST be > 0");return new Promise((function(r,a){{const a=new Uint8Array(e);self.crypto.getRandomValues(a),t&&(a[0]=128|a[0]),r(a)}}))}(16),o=await new Oe(i).addSignature(n).setProtectedHeader({alg:t.alg}).sign();await async function(e,t,r){if(!L(e))throw new m("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(L))throw new m("JWS Signatures missing or incorrect type");for(const a of e.signatures)try{return await Ae({header:a.header,payload:e.payload,protected:a.protected,signature:a.signature},t,r)}catch(e){}throw new b}(o,a)}async function xe(e,t){const r=JSON.parse(e.dataExchange[e.iss]);await Ue(r,t);const a=await oe(t),n=t.alg;return await new Re(e).setProtectedHeader({alg:n}).setIssuedAt().sign(a)}function Ie(e){return null!=e&&"object"==typeof e&&!Array.isArray(e)}function Me(e){return Ie(e)||Array.isArray(e)?Array.isArray(e)?e.map((e=>Array.isArray(e)||Ie(e)?Me(e):e)):Object.keys(e).sort().map((t=>[t,Me(e[t])])):e}function Ne(e){return JSON.stringify(Me(e))}async function je(e,t,r,a){const n=await oe(t),i=await Ce(e,n,a),o=i.payload,s=o.dataExchange[o.iss];if(Ne(t)!==Ne(JSON.parse(s)))throw new Error(`The proof is issued by ${s} instead of ${JSON.stringify(t)}`);for(const e in r){if(void 0===o[e])throw new Error(`Expected key '${e}' not found in proof`);if("dataExchange"===e){const e=r.dataExchange;$e(o.dataExchange,e)}else if(Ne(r[e])!==Ne(o[e]))throw new Error(`Proof's ${e}: ${JSON.stringify(o[e],void 0,2)} does not meet provided value ${JSON.stringify(r[e],void 0,2)}`)}return i}function $e(e,t){const r=["id","orig","dest","hashAlg","cipherblockDgst","blockCommitment","blockCommitment","secretCommitment","schema"];for(const t of r)if("schema"!==t&&(void 0===e[t]||""===e[t]))throw new Error(`${t} is missing on dataExchange.\ndataExchange: ${JSON.stringify(e,void 0,2)}`);for(const r in t)if(Ne(t[r])!==Ne(e[r]))throw new Error(`dataExchange's ${r}: ${JSON.stringify(e[r],void 0,2)} does not meet expected value ${JSON.stringify(t[r],void 0,2)}`)}const Be="SHA-256",Ge="A256GCM";async function Le(e,t,r){const a=await oe(r);return await new _e(t).setProtectedHeader({alg:"dir",enc:Ge,exchangeId:e,kid:r.kid}).encrypt(a)}async function ze(e,t){const a=await oe(t);return await async function(e,t,a){if(e instanceof Uint8Array&&(e=r.decode(e)),"string"!=typeof e)throw new g("Compact JWE must be a string or Uint8Array");const{0:n,1:i,2:o,3:s,4:c,length:d}=e.split(".");if(5!==d)throw new g("Invalid Compact JWE");const h=await ue({ciphertext:s||void 0,iv:o||void 0,protected:n||void 0,tag:c||void 0,encrypted_key:i||void 0},t,a),p={plaintext:h.plaintext,protectedHeader:h.protectedHeader};return"function"==typeof t?{...p,key:h.key}:p}(e,a,{contentEncryptionAlgorithms:[Ge]})}async function Fe(e,t=Be){const r=["SHA-1","SHA-256","SHA-384","SHA-512"];if(!r.includes(t))throw new RangeError(`Valid hash algorith values are any of ${JSON.stringify(r)}`);const a=new TextEncoder,n="string"==typeof e?a.encode(e).buffer:e;let i="";{const e=await crypto.subtle.digest(t,n),r="0123456789abcdef";new Uint8Array(e).forEach((e=>{i+=r[e>>4]+r[15&e]}))}return i}async function Ve(){const e=await De(Ge,{extractable:!0}),r=await ye(e),a=await async function(e,r="sha256"){if(!L(e))throw new TypeError("JWK must be an object");let a;switch(e.kty){case"EC":Te(e.crv,'"crv" (Curve) Parameter'),Te(e.x,'"x" (X Coordinate) Parameter'),Te(e.y,'"y" (Y Coordinate) Parameter'),a={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":Te(e.crv,'"crv" (Subtype of Key Pair) Parameter'),Te(e.x,'"x" (Public Key) Parameter'),a={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":Te(e.e,'"e" (Exponent) Parameter'),Te(e.n,'"n" (Modulus) Parameter'),a={e:e.e,kty:e.kty,n:e.n};break;case"oct":Te(e.k,'"k" (Key Value) Parameter'),a={k:e.k,kty:e.kty};break;default:throw new w('"kty" (Key Type) Parameter missing or unsupported')}const n=t.encode(JSON.stringify(a));return d(await X(r,n))}(r);return r.kid=a,r.alg=Ge,r}return e.ENC_ALG=Ge,e.HASH_ALG=Be,e.NonRepudiationDest=class{constructor(e,t,r){this.jwkPairDest=t,this.publicJwkOrig=r,this.dataExchange={id:e,orig:JSON.stringify(this.publicJwkOrig),dest:JSON.stringify(this.jwkPairDest.publicJwk),hashAlg:Be},this.checked=!1}async init(){await Ue(this.jwkPairDest.publicJwk,this.jwkPairDest.privateJwk),this.checked=!0}async verifyPoO(e,t){this._checkInit();const r={proofType:"PoO",iss:"orig",dataExchange:{...this.dataExchange,cipherblockDgst:await Fe(t,this.dataExchange.hashAlg)}},a=await je(e,this.publicJwkOrig,r);return this.block={jwe:t,poo:e},this.dataExchange=a.payload.dataExchange,a}async generatePoR(){if(this._checkInit(),void 0===this.block?.poo)throw new Error("Before computing a PoR, you have first to receive a valid cipherblock with a PoO and validate the PoO");const e={proofType:"PoR",iss:"dest",dataExchange:this.dataExchange,pooDgst:await Fe(this.block.poo)};return this.block.por=await xe(e,this.jwkPairDest.privateJwk),this.block.por}async verifyPoPAndDecrypt(e,t,r){if(this._checkInit(),void 0===this.block?.por)throw new Error("Cannot verify a PoP if not even a PoR have been created");const a=(await ze(this.block.jwe,JSON.parse(t))).plaintext;if(await Fe(a)!==this.dataExchange.blockCommitment)throw new Error("Decrypted block does not meet the committed one");this.block.secret=JSON.parse(t),this.block.decrypted=a;const n={proofType:"PoP",iss:"orig",dataExchange:this.dataExchange,porDgst:await Fe(this.block.por),secret:t,verificationCode:r},i=await je(e,this.publicJwkOrig,n);return this.block.pop=e,{verified:i,decryptedBlock:a}}_checkInit(){if(!this.checked)throw new Error("NOT INITIALIZED. Before calling any other method, initialize this instance of NonRepudiationOrig calling async method init()")}},e.NonRepudiationOrig=class{constructor(e,t,r,a,n){if(this.jwkPairOrig=t,this.publicJwkDest=r,void 0!==n)this.jwkPairOrig.privateJwk.alg=n,this.jwkPairOrig.publicJwk.alg=n,this.publicJwkDest.alg=n;else if(void 0===this.jwkPairOrig.privateJwk.alg||void 0===this.jwkPairOrig.publicJwk.alg||void 0===this.publicJwkDest.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');this.dataExchange={id:e,orig:JSON.stringify(this.jwkPairOrig.publicJwk),dest:JSON.stringify(this.publicJwkDest),hashAlg:Be},this.block={raw:a},this.checked=!1}async init(){await Ue(this.jwkPairOrig.publicJwk,this.jwkPairOrig.privateJwk),this.block.secret=await Ve();const e=JSON.stringify(this.block.secret);this.block.jwe=await Le(this.dataExchange.id,this.block.raw,this.block.secret),this.dataExchange={...this.dataExchange,cipherblockDgst:await Fe(this.block.jwe,this.dataExchange.hashAlg),blockCommitment:await Fe(this.block.raw,this.dataExchange.hashAlg),secretCommitment:await Fe(e,this.dataExchange.hashAlg)},this.checked=!0}async generatePoO(){this._checkInit();const e={proofType:"PoO",iss:"orig",dataExchange:this.dataExchange};return this.block.poo=await xe(e,this.jwkPairOrig.privateJwk),this.block.poo}async verifyPoR(e){if(this._checkInit(),void 0===this.block?.poo)throw new Error("Cannot verify a PoR if not even a PoO have been created");const t={proofType:"PoR",iss:"dest",dataExchange:this.dataExchange,pooDgst:await Fe(this.block.poo,this.dataExchange.hashAlg)},r=await je(e,this.publicJwkDest,t);return this.block.por=e,r}async generatePoP(e){if(this._checkInit(),void 0===this.block?.por)throw new Error("Before computing a PoP, you have first to receive a verify a PoR");const t={proofType:"PoP",iss:"orig",dataExchange:this.dataExchange,porDgst:await Fe(this.block.por,this.dataExchange.hashAlg),secret:JSON.stringify(this.block.secret),verificationCode:e};return this.block.pop=await xe(t,this.jwkPairOrig.privateJwk),this.block.pop}_checkInit(){if(!this.checked)throw new Error("NOT INITIALIZED. Before calling any other method, initialize this instance of NonRepudiationOrig calling async method init()")}},e.SIGNING_ALG="RS256",e.createProof=xe,e.jweDecrypt=ze,e.jweEncrypt=Le,e.oneTimeSecret=Ve,e.sha=Fe,e.verifyKeyPair=Ue,e.verifyProof=je,Object.defineProperty(e,"__esModule",{value:!0}),e}({});
