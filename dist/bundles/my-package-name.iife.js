var myPackageName=function(e){"use strict";class t extends Error{constructor(e){super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}}class r extends t{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}}class a extends t{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}}const n=new TextEncoder,s=new TextDecoder;var o=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;throw new Error("unable to locate global object")}();const c=e=>{let t=e;"string"==typeof t&&(t=n.encode(t));const r=[];for(let e=0;e<t.length;e+=32768)r.push(String.fromCharCode.apply(null,t.subarray(e,e+32768)));return o.btoa(r.join("")).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")},i=e=>{let t=e;t instanceof Uint8Array&&(t=s.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return new Uint8Array(o.atob(t).split("").map((e=>e.charCodeAt(0))))}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};var d=o.crypto;const h=async(e,t,a)=>{let n;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError("symmetric keys are only applicable for HMAC-based algorithms");n=await d.subtle.importKey("raw",t,{hash:{name:`SHA-${e.substr(-3)}`},name:"HMAC"},!1,["sign"])}else n=t;((e,t)=>{if(e.startsWith("HS")){const r=parseInt(e.substr(-3),10),{length:a}=t.algorithm;if("number"!=typeof a||a<r)throw new TypeError(`${e} requires symmetric keys to be ${r} bits or larger`)}if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}})(e,n);const s=await d.subtle.sign(function(e){switch(e){case"HS256":return{hash:{name:"SHA-256"},name:"HMAC"};case"HS384":return{hash:{name:"SHA-384"},name:"HMAC"};case"HS512":return{hash:{name:"SHA-512"},name:"HMAC"};case"PS256":return{hash:{name:"SHA-256"},name:"RSA-PSS",saltLength:32};case"PS384":return{hash:{name:"SHA-384"},name:"RSA-PSS",saltLength:48};case"PS512":return{hash:{name:"SHA-512"},name:"RSA-PSS",saltLength:64};case"RS256":return{hash:{name:"SHA-256"},name:"RSASSA-PKCS1-v1_5"};case"RS384":return{hash:{name:"SHA-384"},name:"RSASSA-PKCS1-v1_5"};case"RS512":return{hash:{name:"SHA-512"},name:"RSASSA-PKCS1-v1_5"};case"ES256":return{hash:{name:"SHA-256"},name:"ECDSA",namedCurve:"P-256"};case"ES384":return{hash:{name:"SHA-384"},name:"ECDSA",namedCurve:"P-384"};case"ES512":return{hash:{name:"SHA-512"},name:"ECDSA",namedCurve:"P-521"};default:throw new r(`alg ${e} is unsupported either by JOSE or your javascript runtime`)}}(e),n,a);return new Uint8Array(s)};const l=function(e,t,a,n,s){if(void 0!==s.crit&&void 0===n.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;o=void 0!==a?new Map([...Object.entries(a),...t.entries()]):t;for(const t of n.crit){if(!o.has(t))throw new r(`Extension Header Parameter "${t}" is not recognized`);if(void 0===s[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(o.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)}.bind(void 0,a,new Map([["b64",!0]]));class u{constructor(e){this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,t){if(!this._protectedHeader&&!this._unprotectedHeader)throw new a("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!((...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0})(this._protectedHeader,this._unprotectedHeader))throw new a("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader};let o=!0;if(l(null==t?void 0:t.crit,this._protectedHeader,r).has("b64")&&(o=this._protectedHeader.b64,"boolean"!=typeof o))throw new a('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=r;if("string"!=typeof i||!i)throw new a('JWS "alg" (Algorithm) Header Parameter missing or invalid');((e,t)=>{if(e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||e.match(/^A\d{3}(?:GCM)KW$/)){if(t instanceof Uint8Array||"secret"===t.type)return;throw new TypeError('CryptoKey or KeyObject instances for symmetric algorithms must be of type "secret"')}if(t instanceof Uint8Array)throw new TypeError("CryptoKey or KeyObject instances must be used for asymmetric algorithms");if("secret"===t.type)throw new TypeError('CryptoKey or KeyObject instances for asymmetric algorithms must not be of type "secret"')})(i,e);let d,u=this._payload;o&&(u=n.encode(c(u))),d=this._protectedHeader?n.encode(c(JSON.stringify(this._protectedHeader))):n.encode("");const S=function(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let a=0;return e.forEach((e=>{r.set(e,a),a+=e.length})),r}(d,n.encode("."),u),p=await h(i,e,S),y={signature:c(p)};return o&&(y.payload=s.decode(u)),this._unprotectedHeader&&(y.header=this._unprotectedHeader),this._protectedHeader&&(y.protected=s.decode(d)),y}}class S{constructor(e){this._flattened=new u(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}const p=async e=>{var t,a;const{algorithm:n,keyUsages:s}=function(e){let t,a;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:{name:`SHA-${e.alg.substr(-3)}`}},a=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new r(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},a=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},a=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},a=["deriveBits"];break;default:throw new r('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:{name:`SHA-${e.alg.substr(-3)}`}},a=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:{name:`SHA-${e.alg.substr(-3)}`}},a=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:{name:`SHA-${parseInt(e.alg.substr(-3),10)||1}`}},a=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new r('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":case"ES384":case"ES512":t={name:"ECDSA",namedCurve:e.crv},a=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},a=e.d?["deriveBits"]:[];break;default:throw new r('unsupported or invalid JWK "alg" (Algorithm) Parameter value')}break;default:throw new r('unsupported or invalid JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:a}}(e);let o="jwk",c={...e};return delete c.alg,"PBKDF2"===n.name&&(o="raw",c=i(e.k)),d.subtle.importKey(o,c,n,null!==(t=e.ext)&&void 0!==t&&t,null!==(a=e.key_ops)&&void 0!==a?a:s)};async function y(e,t,a){if(!(n=e)||n.constructor!==Object)throw new TypeError("JWK must be an object");var n;if(t||(t=e.alg),"string"!=typeof t||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=a||(a=!0!==e.ext),a?p({...e,alg:t,ext:!1}):i(e.k);case"RSA":if(void 0!==e.oth)throw new r('RSA JWK "oth" (Other Primes Info) Parameter value is unsupported');case"EC":case"OKP":return p({...e,alg:t});default:throw new r('unsupported "kty" (Key Type) Parameter value')}}return e.echo=function(e){return console.log("Browser echoes: "+e),e},e.sign=async function(e){const t=await y({alg:"ES256",crv:"P-256",kty:"EC",d:"VhsfgSRKcvHCGpLyygMbO_YpXc7bVKwi12KQTE4yOR4",x:"ySK38C1jBdLwDsNWKzzBHqKYEE5Cgv-qjWvorUXk9fw",y:"_LeQBw07cf5t57Iavn4j-BqJsAD1dpoz8gokd3sBsOo"}),r="string"==typeof e?(new TextEncoder).encode(e):new Uint8Array(e),a=await new S(r).setProtectedHeader({alg:"ES256"}).sign(t);return console.log(a),a},Object.defineProperty(e,"__esModule",{value:!0}),e}({});
